<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genome Heatmap Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --kb-primary-lightest: #DFEEF6;
            --kb-primary-lighter: #CCE5F3;
            --kb-primary-light: #66B1DB;
            --kb-primary: #026DAA;
            --kb-primary-vivid: #03517D;
            --kb-primary-dark: #023E60;
            --kb-primary-darker: #022940;
            --kb-base-lightest: #F2EFEB;
            --kb-base-lighter: #DED5CB;
            --kb-base-light: #9D9389;
            --kb-base: #6A6158;
            --kb-base-dark: #544C45;
            --kb-base-darker: #3E3832;
            --kb-white: #FFFFFF;
            --kb-ink: #171412;
            --kb-secondary: #009688;
            --kb-secondary-light: #99D5CF;
            --kb-secondary-lightest: #E5F4F1;
            --kb-microbe-orange: #F78E1E;
            --kb-golden-yellow: #FFD200;
            --kb-grass-green: #5E9732;
            --kb-spring-green: #C1CD23;
            --kb-freshwater-blue: #037AC0;
            --kb-ocean-blue: #72CCD2;
            --kb-cyanobacteria-teal: #009688;
            --kb-lupine-purple: #66489D;
            --kb-frost-blue: #C7DBEE;
            --kb-cherry-red: #D2232A;
            --kb-graphite-grey: #9D9389;
            --kb-success: #118577;
            --kb-error: #D2232A;
            --kb-warning: #FFD200;
            --kb-info: #A1B9CF;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: Oxygen, -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, ubuntu, roboto, noto, segoe ui, arial, sans-serif;
            background: var(--kb-base-lightest);
            color: var(--kb-base-darker);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .tab-bar {
            display: flex;
            background: var(--kb-white);
            border-bottom: 1px solid var(--kb-base-lighter);
            padding: 0 16px;
            flex-shrink: 0;
        }
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--kb-base);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .tab-btn:hover { color: var(--kb-primary); background: var(--kb-primary-lightest); }
        .tab-btn.active { color: var(--kb-primary); border-bottom-color: var(--kb-primary); }
        .tab-content { display: none; flex: 1; overflow: hidden; }
        .tab-content.active { display: flex; }
        .sidebar {
            width: 280px;
            background: var(--kb-white);
            padding: 0;
            overflow-y: auto;
            border-right: 1px solid var(--kb-base-lighter);
            box-shadow: 2px 0 4px rgba(0,0,0,0.05);
        }
        .sidebar-header {
            background: var(--kb-primary);
            color: white;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
        }
        .sidebar-section { border-bottom: 1px solid var(--kb-base-lighter); }
        .sidebar-section-title {
            padding: 10px 16px;
            font-size: 11px;
            font-weight: 600;
            color: var(--kb-base);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: var(--kb-base-lightest);
            border-bottom: 1px solid var(--kb-base-lighter);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .sidebar-section-title:hover { background: var(--kb-base-lighter); }
        .sidebar-section-title .toggle-icon { font-size: 10px; color: var(--kb-base-light); transition: transform 0.2s; }
        .sidebar-section.collapsed .toggle-icon { transform: rotate(-90deg); }
        .sidebar-section.collapsed > :not(.sidebar-section-title) { display: none !important; }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--kb-white);
        }
        /* Search */
        .search-box {
            padding: 8px 12px;
            border-bottom: 1px solid var(--kb-base-lighter);
        }
        .search-box input {
            width: 100%;
            padding: 7px 10px;
            border: 1px solid var(--kb-base-lighter);
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }
        .search-box input:focus { border-color: var(--kb-primary); box-shadow: 0 0 0 2px rgba(2,109,170,0.15); }
        .search-info { font-size: 10px; color: var(--kb-base-light); margin-top: 4px; display: none; }
        /* Track list */
        .track-list { padding: 4px 0; }
        .track-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            cursor: pointer;
            transition: background 0.15s;
            border-left: 3px solid transparent;
        }
        .track-item:hover { background: var(--kb-base-lightest); }
        .track-item.active { background: var(--kb-primary-lightest); border-left-color: var(--kb-primary); }
        .track-item input[type="checkbox"] {
            margin-right: 6px;
            width: 14px;
            height: 14px;
            accent-color: var(--kb-primary);
            cursor: pointer;
        }
        .track-item label { flex: 1; cursor: pointer; font-size: 12px; color: var(--kb-base-dark); }
        .track-item .sort-btn {
            background: var(--kb-primary);
            border: none;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            opacity: 0;
            transition: opacity 0.15s;
            font-weight: 500;
        }
        .track-item:hover .sort-btn { opacity: 1; }
        .track-item .sort-btn:hover { background: var(--kb-primary-dark); }
        /* Analysis views */
        .analysis-views { padding: 4px 8px; }
        .analysis-view-btn {
            display: flex; align-items: center; gap: 6px;
            width: 100%; text-align: left;
            background: var(--kb-base-lightest); border: 1px solid var(--kb-base-lighter); color: var(--kb-base-darker);
            padding: 6px 10px; border-radius: 4px; cursor: pointer;
            font-size: 11px; transition: all 0.15s; margin-bottom: 3px;
        }
        .analysis-view-btn:hover { background: var(--kb-primary-lightest); border-color: var(--kb-primary-light); }
        .analysis-view-btn.active { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .analysis-view-btn .av-name { font-weight: 600; }
        .analysis-view-btn .av-desc { font-size: 10px; color: var(--kb-base); }
        .analysis-view-btn.active .av-desc { color: var(--kb-primary-lighter); }
        .av-info-btn {
            width: 12px; height: 12px; border-radius: 50%; border: 1px solid var(--kb-base-lighter);
            background: var(--kb-base-lightest); color: var(--kb-base-light); font-size: 8px; cursor: help;
            display: inline-flex; align-items: center; justify-content: center;
            flex-shrink: 0; margin-left: auto;
        }
        .av-info-btn:hover { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .analysis-view-btn.active .av-info-btn { border-color: var(--kb-primary-light); background: var(--kb-primary-dark); color: white; }
        /* Sort presets */
        .sort-presets { padding: 6px 12px; display: flex; flex-wrap: wrap; gap: 4px; }
        .sort-preset-wrapper { position: relative; display: inline-flex; align-items: center; }
        .sort-preset-btn {
            background: var(--kb-base-lightest);
            border: 1px solid var(--kb-base-lighter);
            color: var(--kb-base-darker);
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s;
        }
        .sort-preset-btn:hover { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .sort-preset-btn.active { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .sort-info-btn {
            width: 12px; height: 12px; border-radius: 50%; border: 1px solid var(--kb-base-lighter);
            background: var(--kb-base-lightest); color: var(--kb-base-light); font-size: 8px; cursor: help;
            display: inline-flex; align-items: center; justify-content: center;
            margin-left: 2px; flex-shrink: 0;
        }
        .sort-info-btn:hover { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        /* Actions */
        .action-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            color: var(--kb-primary);
            font-size: 12px;
        }
        .action-item:hover { background: var(--kb-primary-lightest); }
        .action-item .icon { margin-right: 6px; }
        /* Stats bar */
        .kpi-bar {
            display: flex;
            align-items: baseline;
            gap: 0;
            padding: 6px 12px;
            background: var(--kb-primary-darker);
            color: var(--kb-frost-blue);
            font-size: 12px;
            overflow-x: auto;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .kpi-stat { display: inline-flex; align-items: baseline; gap: 4px; padding: 0 10px; }
        .kpi-stat:not(:last-child) { border-right: 1px solid var(--kb-primary-dark); }
        .kpi-value { font-size: 14px; font-weight: 700; font-variant-numeric: tabular-nums; }
        .kpi-label { font-size: 10px; color: var(--kb-primary-light); }
        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: var(--kb-white);
            border-bottom: 1px solid var(--kb-base-lighter);
            gap: 12px;
        }
        .toolbar button {
            background: var(--kb-base-lightest);
            border: 1px solid var(--kb-base-lighter);
            color: var(--kb-base-darker);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.15s;
        }
        .toolbar button:hover { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .toolbar .zoom-controls { display: flex; align-items: center; gap: 6px; }
        .toolbar .zoom-controls span { font-size: 11px; color: var(--kb-base); font-weight: 500; }
        .toolbar input[type="range"] { width: 120px; accent-color: var(--kb-primary); }
        .toolbar .info {
            margin-left: auto;
            font-size: 11px;
            color: var(--kb-base);
            background: var(--kb-base-lightest);
            padding: 3px 8px;
            border-radius: 4px;
        }
        /* Heatmap */
        .heatmap-container { flex: 1; position: relative; overflow: hidden; background: var(--kb-white); }
        #heatmap { display: block; }
        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--kb-base-darker);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 380px;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            line-height: 1.5;
        }
        .tooltip .gene-id { color: var(--kb-primary-light); font-weight: bold; font-size: 12px; }
        .tooltip .func { color: var(--kb-base-light); font-style: italic; margin-top: 4px; display: block; }
        .tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
        .tooltip .tt-label { color: var(--kb-base-light); }
        .tooltip .tt-val { color: var(--kb-base-lightest); font-weight: 500; }
        .tooltip .tt-highlight { color: var(--kb-primary-light); font-weight: 600; }
        .tooltip .tt-section { margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--kb-base-dark); }
        /* Gene Detail Panel */
        .gene-detail-panel {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 340px;
            background: var(--kb-white);
            border-left: 1px solid var(--kb-base-lighter);
            box-shadow: -4px 0 12px rgba(0,0,0,0.08);
            overflow-y: auto;
            z-index: 500;
            display: none;
            font-size: 12px;
        }
        .gene-detail-panel.open { display: block; }
        .gene-detail-header {
            padding: 12px 16px;
            background: var(--kb-primary);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .gene-detail-header h3 { font-size: 14px; font-weight: 600; }
        .gene-detail-close {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
        }
        .gene-detail-body { padding: 12px 16px; }
        .detail-section { margin-bottom: 14px; }
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--kb-base);
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--kb-base-lighter);
        }
        .detail-row { display: flex; justify-content: space-between; padding: 3px 0; }
        .detail-label { color: var(--kb-base); }
        .detail-value { color: var(--kb-base-darker); font-weight: 500; text-align: right; max-width: 200px; word-break: break-word; }
        .detail-func {
            background: var(--kb-base-lightest);
            padding: 8px;
            border-radius: 4px;
            color: var(--kb-base-darker);
            font-style: italic;
            line-height: 1.4;
        }
        .cons-bar {
            display: inline-block;
            width: 40px;
            height: 10px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }
        /* Genome selector */
        .genome-minimap {
            background: var(--kb-white);
            border-top: 1px solid var(--kb-base-lighter);
            position: relative;
            height: 56px;
            user-select: none;
        }
        .genome-minimap canvas {
            display: block;
            width: 100%;
            height: 36px;
            cursor: pointer;
        }
        .minimap-viewport {
            position: absolute;
            top: 0;
            height: 36px;
            background: rgba(2, 109, 170, 0.15);
            border: 2px solid rgba(2, 109, 170, 0.6);
            border-radius: 2px;
            cursor: grab;
            min-width: 6px;
            box-sizing: border-box;
            transition: background 0.1s;
        }
        .minimap-viewport:hover { background: rgba(2, 109, 170, 0.25); }
        .minimap-viewport.dragging { cursor: grabbing; background: rgba(2, 109, 170, 0.3); }
        .minimap-info {
            display: flex;
            justify-content: space-between;
            padding: 2px 8px;
            font-size: 10px;
            color: var(--kb-base-light);
        }
        #position-info {
            font-size: 10px;
            color: var(--kb-base);
            background: var(--kb-base-lightest);
            padding: 1px 6px;
            border-radius: 3px;
        }
        /* Legend */
        .legend {
            display: flex;
            gap: 16px;
            padding: 6px 12px;
            background: var(--kb-base-lightest);
            border-top: 1px solid var(--kb-base-lighter);
            font-size: 10px;
            color: var(--kb-base);
            flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 3px; cursor: help; position: relative; }
        .legend-color {
            width: 14px;
            height: 10px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .legend-label { font-weight: 500; margin-right: 6px; color: var(--kb-base-dark); }
        /* Track info tooltip */
        .track-item .info-btn {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid var(--kb-base-lighter);
            background: var(--kb-base-lightest);
            color: var(--kb-base-light);
            font-size: 9px;
            cursor: help;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            flex-shrink: 0;
        }
        .track-item .info-btn:hover { background: var(--kb-primary); color: white; border-color: var(--kb-primary); }
        .track-desc-tooltip {
            position: fixed;
            background: var(--kb-base-darker);
            color: var(--kb-base-lightest);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 11px;
            max-width: 360px;
            z-index: 2000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            line-height: 1.5;
            display: none;
        }
        .track-desc-tooltip strong { color: var(--kb-white); }
        .track-desc-tooltip .tt-section { margin-top: 6px; }
        .track-desc-tooltip .tt-label { color: var(--kb-primary-light); font-weight: 600; display: block; margin-top: 5px; }
        .track-desc-tooltip .tt-colors { display: flex; gap: 6px; margin-top: 3px; align-items: center; font-size: 10px; }
        .track-desc-tooltip .tt-swatch { width: 12px; height: 12px; border-radius: 2px; display: inline-block; }
        /* Tree View */
        .tree-container { flex: 1; overflow: auto; background: var(--kb-white); position: relative; }
        .tree-container svg { display: block; }
        .tree-toolbar { padding: 8px 12px; background: var(--kb-white); border-bottom: 1px solid var(--kb-base-lighter); display: flex; align-items: center; gap: 12px; font-size: 11px; color: var(--kb-base); }
        .tree-leaf { cursor: pointer; }
        .tree-leaf:hover text { fill: var(--kb-primary) !important; }
        .tree-leaf.user-genome text { fill: var(--kb-cherry-red); font-weight: 700; }
        .tree-tooltip {
            position: fixed; background: var(--kb-base-darker); color: white;
            padding: 10px 14px; border-radius: 6px; font-size: 11px;
            pointer-events: none; z-index: 1000; max-width: 350px;
            display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.2); line-height: 1.5;
        }
        .stat-toggle { display: flex; align-items: center; gap: 6px; padding: 5px 12px; font-size: 12px; cursor: pointer; }
        .stat-toggle:hover { background: var(--kb-base-lightest); }
        .stat-toggle input { accent-color: var(--kb-primary); }
        .stat-bar-label { font-size: 9px; fill: var(--kb-base); }
        /* Cluster View */
        .cluster-container { flex: 1; position: relative; overflow: hidden; background: var(--kb-white); }
        #cluster-canvas { display: block; }
        .cluster-toolbar { padding: 8px 12px; background: var(--kb-white); border-bottom: 1px solid var(--kb-base-lighter); display: flex; align-items: center; gap: 12px; font-size: 11px; }
        .cluster-legend { display: flex; gap: 16px; padding: 6px 12px; background: var(--kb-base-lightest); border-top: 1px solid var(--kb-base-lighter); font-size: 10px; color: var(--kb-base); flex-wrap: wrap; flex-shrink: 0; }
        .cluster-legend .legend-item { display: flex; align-items: center; gap: 3px; }
        .cluster-select { padding: 4px 8px; border: 1px solid var(--kb-base-lighter); border-radius: 4px; font-size: 11px; background: var(--kb-white); }
        /* Summary/Dashboard View */
        .summary-container { flex: 1; overflow-y: auto; background: var(--kb-base-lightest); padding: 24px; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; max-width: 1200px; }
        .summary-card { background: var(--kb-white); border: 1px solid var(--kb-base-lighter); border-radius: 8px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .summary-card-title { font-size: 16px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        .summary-card-title .icon { font-size: 20px; }
        .summary-metric { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--kb-base-lightest); }
        .summary-metric:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .summary-metric-label { font-size: 12px; color: var(--kb-base); }
        .summary-metric-value { font-size: 18px; font-weight: 600; color: var(--kb-primary); }
        .summary-metric-value.warning { color: #E07B39; }
        .summary-metric-value.good { color: #1FA860; }
        .summary-list { max-height: 300px; overflow-y: auto; }
        .summary-list-item { font-size: 11px; padding: 8px 0; border-bottom: 1px solid var(--kb-base-lightest); font-family: monospace; }
        .summary-list-item:last-child { border-bottom: none; }
        .summary-list-item .rxn-id { color: var(--kb-accent); font-weight: 600; }
        .summary-list-item .rxn-func { color: var(--kb-base); margin-left: 8px; }
        /* Metabolic Map View */
        #metabolic-container { flex: 1; position: relative; overflow: hidden; background: var(--kb-white); }
        #metabolic-container svg { width: 100%; height: 100%; }
        .metabolic-toolbar { padding: 8px 12px; background: var(--kb-white); border-bottom: 1px solid var(--kb-base-lighter); display: flex; align-items: center; gap: 12px; font-size: 11px; }
        .metabolic-legend { padding: 8px 12px; font-size: 10px; color: var(--kb-base-dark); line-height: 1.8; }
        .metabolic-legend .legend-row { display: flex; align-items: center; gap: 6px; }
        .metabolic-legend .legend-swatch { width: 14px; height: 14px; border-radius: 2px; flex-shrink: 0; border: 1px solid rgba(0,0,0,0.1); }
        .metabolic-legend .gradient-bar { height: 12px; width: 100px; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1); }
        .rxn-detail { padding: 8px 12px; font-size: 11px; color: var(--kb-base-dark); line-height: 1.6; }
        .rxn-detail .rxn-id { font-weight: 600; color: var(--kb-base-darker); font-size: 12px; margin-bottom: 4px; }
        .rxn-detail .rxn-eq { background: var(--kb-base-lightest); padding: 6px 8px; border-radius: 4px; font-size: 10px; margin: 6px 0; line-height: 1.5; word-break: break-word; }
        .rxn-detail .rxn-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .rxn-detail .rxn-label { color: var(--kb-base); }
        .rxn-detail .rxn-val { font-weight: 500; color: var(--kb-base-darker); }
        .rxn-gene-link { color: var(--kb-primary); cursor: pointer; text-decoration: underline; }
        .rxn-gene-link:hover { color: var(--kb-primary-dark); }
        .metabolic-loading { display: flex; align-items: center; justify-content: center; height: 100%; color: var(--kb-base-light); font-size: 14px; }
        /* Reaction Table */
        .reaction-table-container { flex: 1; overflow: auto; background: var(--kb-white); display: none; flex-direction: column; }
        .reaction-table-toolbar { padding: 12px; background: var(--kb-base-lightest); border-bottom: 1px solid var(--kb-base-lighter); display: flex; gap: 16px; align-items: center; font-size: 12px; flex-wrap: wrap; }
        .reaction-table-toolbar select { padding: 6px 10px; border: 1px solid var(--kb-base-lighter); border-radius: 4px; font-size: 12px; background: white; }
        .reaction-table-toolbar span { font-weight: 500; }
        .reaction-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .reaction-table th { background: var(--kb-base-lightest); padding: 8px; text-align: left; border-bottom: 2px solid var(--kb-base-lighter); position: sticky; top: 0; cursor: pointer; user-select: none; }
        .reaction-table th:hover { background: var(--kb-base-light); }
        .reaction-table td { padding: 6px 8px; border-bottom: 1px solid var(--kb-base-lightest); }
        .reaction-table tr:hover { background: var(--kb-base-lightest); }
        .reaction-table .rxn-id-col { font-weight: 600; color: var(--kb-accent); cursor: help; }
        .reaction-table .rxn-id-col:hover { text-decoration: underline; }
        .reaction-table .rxn-eq-col { max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 10px; }
        .reaction-table .rxn-genes-col { max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 10px; }
        /* Help/Glossary View */
        .help-container { flex: 1; overflow-y: auto; background: var(--kb-base-lightest); padding: 24px; }
        .help-content { max-width: 900px; margin: 0 auto; }
        .help-section { background: var(--kb-white); border: 1px solid var(--kb-base-lighter); border-radius: 8px; padding: 24px; margin-bottom: 20px; }
        .help-section h2 { font-size: 20px; font-weight: 600; color: var(--kb-primary); margin-top: 0; margin-bottom: 16px; border-bottom: 2px solid var(--kb-primary-light); padding-bottom: 8px; }
        .help-section h3 { font-size: 16px; font-weight: 600; color: var(--kb-base-darker); margin-top: 20px; margin-bottom: 12px; }
        .help-section p { line-height: 1.6; color: var(--kb-base-dark); margin-bottom: 12px; }
        .help-term { display: grid; grid-template-columns: 100px 1fr; gap: 12px; padding: 12px; margin-bottom: 8px; background: var(--kb-base-lightest); border-radius: 4px; align-items: start; }
        .help-term-name { font-weight: 600; color: var(--kb-primary); font-family: monospace; font-size: 13px; }
        .help-term-def { font-size: 13px; color: var(--kb-base-dark); line-height: 1.5; }
        .help-term-def em { color: var(--kb-base); font-style: normal; display: block; margin-top: 4px; font-size: 12px; }
        .help-color-demo { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
        .help-color-swatch { width: 20px; height: 20px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1); }
        .help-code { background: var(--kb-base-darker); color: var(--kb-white); padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 12px; }
        .help-analysis-view { background: var(--kb-base-lightest); padding: 16px; border-left: 4px solid var(--kb-primary); margin-bottom: 16px; border-radius: 4px; }
        .help-analysis-view h4 { font-size: 14px; font-weight: 600; color: var(--kb-primary); margin-top: 0; margin-bottom: 8px; }
        .help-analysis-view .purpose { font-size: 13px; color: var(--kb-base-dark); margin-bottom: 8px; }
        .help-analysis-view .tracks { font-size: 12px; color: var(--kb-base); }
        .help-analysis-view .use-case { font-size: 12px; color: var(--kb-base-dark); background: white; padding: 8px; border-radius: 3px; margin-top: 8px; font-style: italic; }
        /* Distributions Tab */
        .distributions-container { flex: 1; overflow: auto; background: var(--kb-white); padding: 24px; }
        .dist-chart-container { background: white; border: 1px solid var(--kb-base-lighter); border-radius: 8px; padding: 24px; margin-bottom: 20px; }
        .dist-chart-title { font-size: 16px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 16px; }
        .dist-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 20px; }
        .dist-stat-card { background: var(--kb-base-lightest); padding: 12px; border-radius: 6px; border-left: 3px solid var(--kb-primary); }
        .dist-stat-label { font-size: 11px; color: var(--kb-base); text-transform: uppercase; font-weight: 500; }
        .dist-stat-value { font-size: 20px; font-weight: 600; color: var(--kb-base-dark); margin-top: 4px; }
        .dist-chart-svg { width: 100%; height: 300px; }
        .dist-bar { transition: opacity 0.2s; }
        .dist-bar:hover { opacity: 0.7; }
        .dist-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 16px; font-size: 12px; }
        .dist-legend-item { display: flex; align-items: center; gap: 6px; }
        .dist-legend-color { width: 16px; height: 16px; border-radius: 3px; }
    </style>
</head>
<body>
    <!-- Shared KPI Bar -->
    <div class="kpi-bar" id="kpi-bar"></div>
    <!-- Tab Bar -->
    <div class="tab-bar">
        <img src="kbase_logo.png" alt="KBase" style="height: 28px; margin-right: 12px; align-self: center;">
        <button class="tab-btn active" data-tab="tracks" onclick="switchTab('tracks')">Tracks</button>
        <button class="tab-btn" data-tab="distributions" onclick="switchTab('distributions')">Distributions</button>
        <button class="tab-btn" data-tab="tree" onclick="switchTab('tree')">Tree</button>
        <button class="tab-btn" data-tab="cluster" onclick="switchTab('cluster')">Cluster</button>
        <button class="tab-btn" data-tab="metabolic" onclick="switchTab('metabolic')">Metabolic Map</button>
        <button class="tab-btn" data-tab="help" onclick="switchTab('help')" style="margin-left: auto;">Help</button>
    </div>
    <!-- Tab: Tracks -->
    <div class="tab-content active" id="tab-tracks">
        <div class="sidebar">
            <div class="sidebar-header">Genome Heatmap Viewer</div>
            <!-- Search -->
            <div class="search-box">
                <input type="text" id="gene-search" placeholder="Search genes (ID, function, KO)...">
                <div class="search-info" id="search-info"></div>
            </div>
            <!-- Analysis Views -->
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Analysis Views</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="analysis-views" id="analysis-views"></div>
            </div>
            <!-- Data Tracks -->
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Data Tracks</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="track-list" id="track-list"></div>
            </div>
            <!-- Sort Presets -->
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Sort By</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="sort-presets" id="sort-presets"></div>
            </div>
            <!-- Actions -->
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Actions</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="action-item" onclick="resetSort()">
                    <span class="icon">&#8634;</span> Reset to genome order
                </div>
                <div class="action-item" onclick="selectAll()">
                    <span class="icon">&#9745;</span> Select all tracks
                </div>
                <div class="action-item" onclick="deselectAll()">
                    <span class="icon">&#9744;</span> Deselect all tracks
                </div>
                <div class="action-item" onclick="exportCurrentView()">
                    <span class="icon">&#8595;</span> Export current view (CSV)
                </div>
                <div class="action-item" onclick="exportAllGenes()">
                    <span class="icon">&#8595;</span> Export all genes (CSV)
                </div>
            </div>
        </div>
        <div class="main">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="zoom-controls">
                    <span>Zoom:</span>
                    <input type="range" id="zoom-slider" min="1" max="100" value="1">
                    <button onclick="resetZoom()">Reset</button>
                </div>
                <div class="info" id="info">Loading...</div>
            </div>
            <!-- Heatmap -->
            <div class="heatmap-container">
                <canvas id="heatmap"></canvas>
                <div class="tooltip" id="tooltip"></div>
                <div class="track-desc-tooltip" id="track-desc-tooltip"></div>
            </div>
            <!-- Legend -->
            <div class="legend" id="legend"></div>
            <!-- Genome Minimap Navigation -->
            <div class="genome-minimap" id="genome-minimap">
                <canvas id="minimap-canvas"></canvas>
                <div class="minimap-viewport" id="minimap-viewport"></div>
                <div class="minimap-info">
                    <span id="minimap-label">Genome overview</span>
                    <span id="position-info">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab: Tree -->
    <div class="tab-content" id="tab-tree">
        <div class="sidebar">
            <div class="sidebar-header">Genome Tree</div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Stats Bars</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div id="tree-stat-toggles"></div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Genome Comparison</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px;" id="genome-comparison">
                    Loading...
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Tree Info</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px; color: var(--kb-base); line-height: 1.6;" id="tree-info">
                    Loading tree data...
                </div>
            </div>
        </div>
        <div class="main">
            <div class="tree-toolbar" id="tree-toolbar">
                <span>UPGMA dendrogram based on Jaccard distance of pangenome cluster presence/absence</span>
            </div>
            <div class="tree-container" id="tree-container"></div>
        </div>
        <div class="tree-tooltip" id="tree-tooltip"></div>
    </div>

    <!-- Tab: Cluster -->
    <div class="tab-content" id="tab-cluster">
        <div class="sidebar">
            <div class="sidebar-header">Gene Clusters</div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Embedding</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 6px 12px;">
                    <select class="cluster-select" id="cluster-embedding" onchange="changeClusterEmbedding()">
                        <option value="features">Gene Features</option>
                        <option value="presence">Presence/Absence</option>
                    </select>
                    <div style="font-size: 10px; color: var(--kb-base-light); margin-top: 4px;" id="cluster-embed-desc">
                        UMAP of conservation, consistency scores, annotation counts, protein length
                    </div>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Color By</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 6px 12px;">
                    <select class="cluster-select" id="cluster-color-by" onchange="changeClusterColor()">
                        <option value="pan_category">Core/Accessory</option>
                        <option value="conservation">Conservation</option>
                        <option value="avg_cons">Avg Consistency</option>
                        <option value="localization">Localization</option>
                        <option value="n_ko"># KEGG Terms</option>
                        <option value="n_modules">Module Hits</option>
                        <option value="cluster_size">Cluster Size</option>
                        <option value="specificity">Specificity</option>
                    </select>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Search</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="search-box">
                    <input type="text" id="cluster-search" placeholder="Search genes...">
                    <div class="search-info" id="cluster-search-info"></div>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Info</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px; color: var(--kb-base); line-height: 1.6;" id="cluster-info">
                    Loading cluster data...
                </div>
            </div>
        </div>
        <div class="main">
            <div class="cluster-toolbar" id="cluster-toolbar">
                <span id="cluster-toolbar-info">UMAP projection of 4,617 genes</span>
                <span id="cluster-zoom-info" style="margin-left:8px; font-size:11px; color:#9D9389;"></span>
                <button id="cluster-reset-zoom" style="margin-left:auto; padding:3px 10px; font-size:11px; border:1px solid var(--kb-base-lighter); border-radius:4px; background:var(--kb-white); color:var(--kb-base-dark); cursor:pointer; display:none;" onclick="resetClusterZoom()">Reset Zoom</button>
            </div>
            <div class="cluster-container">
                <canvas id="cluster-canvas"></canvas>
                <div class="tooltip" id="cluster-tooltip"></div>
            </div>
            <div class="cluster-legend" id="cluster-legend"></div>
        </div>
    </div>

    <!-- Tab: Distributions -->
    <div class="tab-content" id="tab-distributions">
        <div class="sidebar">
            <div class="sidebar-header">Track Distributions</div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Select Track</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px;">
                    <select id="dist-track-select" style="width: 100%; padding: 8px; border: 1px solid var(--kb-base-lighter); border-radius: 4px; font-size: 12px; background: white;" onchange="renderDistributions()">
                        <option value="">-- Choose a track --</option>
                    </select>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>About</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px; color: var(--kb-base); line-height: 1.5;">
                    <p style="margin: 0 0 8px 0;">Visualize the distribution of gene counts across different track values.</p>
                    <p style="margin: 0;"><strong>Categorical tracks</strong> (e.g., Core/Accessory) show pie and bar charts. <strong>Numerical tracks</strong> (e.g., Conservation) show histograms.</p>
                </div>
            </div>
        </div>
        <div class="distributions-container" id="distributions-container">
            <div style="text-align: center; color: var(--kb-base-light); margin-top: 100px;">
                <p style="font-size: 16px; margin-bottom: 8px;">ðŸ“Š Select a track to view its distribution</p>
                <p style="font-size: 12px;">Use the dropdown in the sidebar to choose a track</p>
            </div>
        </div>
    </div>

    <!-- Tab: Metabolic Map -->
    <div class="tab-content" id="tab-metabolic">
        <div class="sidebar">
            <div class="sidebar-header">Metabolic Map</div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Actions</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="action-item" onclick="exportReactions()" style="padding: 8px 12px; cursor: pointer;">
                    <span class="icon">&#8595;</span> Export reactions (CSV)
                </div>
                <div class="action-item" onclick="toggleReactionTable()" style="padding: 8px 12px; cursor: pointer;">
                    <span class="icon" id="table-toggle-icon">&#9776;</span> <span id="table-toggle-text">Show reaction table</span>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Map</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 6px 12px;">
                    <select class="cluster-select" id="metabolic-map-select" onchange="changeMetabolicMap()" style="width:100%;">
                        <option value="full">Global Metabolism</option>
                        <option value="core">Core Metabolism</option>
                    </select>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">
                    <span>Color By</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 6px 12px;">
                    <select class="cluster-select" id="metabolic-color-by" onchange="changeMetabolicColor()" style="width:100%;">
                        <option value="conservation">Pangenome Conservation</option>
                        <option value="presence">Presence / Absence</option>
                        <option value="flux_rich">Flux (Rich Media)</option>
                        <option value="flux_min">Flux (Minimal Media)</option>
                        <option value="class_rich">Flux Class (Rich)</option>
                        <option value="class_min">Flux Class (Minimal)</option>
                    </select>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Legend</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="metabolic-legend" id="metabolic-legend"></div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Stats</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px; color: var(--kb-base); line-height: 1.6;" id="metabolic-stats">
                    Loading...
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Pathway Coverage</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px; color: var(--kb-base); line-height: 1.5;" id="pathway-coverage">
                    Loading...
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Growth Phenotypes</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 11px;" id="growth-phenotypes">
                    Loading...
                </div>
            </div>
            <div class="sidebar-section collapsed">
                <div class="sidebar-section-title" >
                    <span>Unmapped Reactions</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div style="padding: 8px 12px; font-size: 10px; color: var(--kb-base); line-height: 1.4; max-height: 200px; overflow-y: auto;" id="metabolic-unmapped">
                    Loading...
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" >
                    <span>Reaction Detail</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="rxn-detail" id="metabolic-rxn-detail">
                    <span style="color:#9D9389;">Click a reaction on the map to see details</span>
                </div>
            </div>
        </div>
        <div class="main" style="display:flex; flex-direction:column;">
            <div class="metabolic-toolbar" id="metabolic-toolbar">
                <span id="metabolic-toolbar-info">Metabolic pathway map</span>
            </div>
            <div id="metabolic-container">
                <div class="metabolic-loading" id="metabolic-loading">Click the Metabolic Map tab to load...</div>
            </div>
            <div class="reaction-table-container" id="reaction-table-container">
                <div class="reaction-table-toolbar">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span>Filter:</span>
                        <select id="rxn-table-filter" onchange="filterReactionTable()">
                            <option value="metabolic" selected>Metabolic (no exchange/sink)</option>
                            <option value="all">All reactions</option>
                            <option value="on_map">On map</option>
                            <option value="not_on_map">Not on map</option>
                            <option value="has_genes">With genes</option>
                            <option value="no_genes">No genes</option>
                            <option value="gapfilled">Gapfilled only</option>
                            <option value="gene_supported">Gene-supported only</option>
                            <option value="exchange">Exchange/Sink only</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span>Sort:</span>
                        <select id="rxn-table-sort" onchange="sortReactionTable()">
                            <option value="id">Reaction ID</option>
                            <option value="conservation">Conservation</option>
                            <option value="flux_rich">Flux (rich)</option>
                            <option value="flux_min">Flux (minimal)</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span>Search:</span>
                        <input type="text" id="rxn-table-search" placeholder="ID, equation, or gene..."
                               style="padding: 4px 8px; border: 1px solid var(--kb-base-lighter); border-radius: 4px; font-size: 11px; width: 200px;"
                               oninput="filterReactionTable()">
                    </div>
                    <span id="rxn-table-count" style="margin-left: auto; font-weight: 600; color: var(--kb-primary);"></span>
                </div>
                <div style="overflow: auto; flex: 1;">
                    <table class="reaction-table" id="reaction-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Equation</th>
                                <th>Genes</th>
                                <th>Cons</th>
                                <th>Flux (R)</th>
                                <th>Class (R)</th>
                                <th>Flux (M)</th>
                                <th>Class (M)</th>
                            </tr>
                        </thead>
                        <tbody id="reaction-table-body">
                            <tr><td colspan="8" style="text-align:center; padding:20px;">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab: Help/Glossary -->
    <div class="tab-content" id="tab-help">
        <div class="help-container">
            <div class="help-content">
                <!-- Terminology -->
                <div class="help-section">
                    <h2>Terminology & Abbreviations</h2>

                    <h3>Annotation Sources</h3>
                    <div class="help-term">
                        <div class="help-term-name">EC</div>
                        <div class="help-term-def">
                            <strong>Enzyme Commission number</strong> -Hierarchical classification of enzyme function based on chemical reaction catalyzed.
                            <em>Example: EC 1.1.1.1 = alcohol dehydrogenase</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">KO</div>
                        <div class="help-term-def">
                            <strong>KEGG Orthology</strong> -Functional classification system from the KEGG database linking genes to pathways and modules.
                            <em>Example: K00001 = alcohol dehydrogenase ortholog group</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">COG</div>
                        <div class="help-term-def">
                            <strong>Clusters of Orthologous Groups</strong> -Protein families classified by evolutionary relationships and functional categories.
                            <em>Example: COG1062 = zincin-like metalloproteases</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Pfam</div>
                        <div class="help-term-def">
                            <strong>Protein families database</strong> -Collection of protein domain alignments and hidden Markov models.
                            <em>Example: PF00106 = short-chain dehydrogenase domain</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">GO</div>
                        <div class="help-term-def">
                            <strong>Gene Ontology</strong> -Standardized vocabulary describing gene function (molecular function, biological process, cellular component).
                            <em>Example: GO:0006096 = glycolytic process</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">RAST</div>
                        <div class="help-term-def">
                            <strong>Rapid Annotation using Subsystem Technology</strong> -Automated annotation pipeline for bacterial and archaeal genomes.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Bakta</div>
                        <div class="help-term-def">
                            <strong>Bacterial annotation tool</strong> -Comprehensive annotation system combining multiple databases and prediction tools.
                        </div>
                    </div>

                    <h3>Pangenome Terms</h3>
                    <div class="help-term">
                        <div class="help-term-name">Core</div>
                        <div class="help-term-def">
                            Genes present in >95% of reference genomes. Represent essential or highly conserved functions.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Accessory</div>
                        <div class="help-term-def">
                            Genes present in 5-95% of genomes. Provide strain-specific capabilities or niche adaptation.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Singleton</div>
                        <div class="help-term-def">
                            Genes present in <5% of genomes. Unique or rare genes, may indicate horizontal gene transfer.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Conservation</div>
                        <div class="help-term-def">
                            Fraction of reference genomes containing an ortholog of this gene (0.0 = unique, 1.0 = universal).
                        </div>
                    </div>

                    <h3>Metabolic Terms</h3>
                    <div class="help-term">
                        <div class="help-term-name">Compartments</div>
                        <div class="help-term-def">
                            Cellular locations for reactions:
                            <br><span class="help-code">c0</span> = Cytoplasm
                            <br><span class="help-code">e0</span> = Extracellular
                            <br><span class="help-code">p0</span> = Periplasm (bacterial-specific)
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">FBA</div>
                        <div class="help-term-def">
                            <strong>Flux Balance Analysis</strong> -Mathematical modeling to predict metabolic flux through reactions under given growth conditions.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Gapfilling</div>
                        <div class="help-term-def">
                            Reactions added computationally to complete metabolic pathways when gene evidence is missing but function is inferred.
                        </div>
                    </div>

                    <h3>Statistical Terms</h3>
                    <div class="help-term">
                        <div class="help-term-name">ANI</div>
                        <div class="help-term-def">
                            <strong>Average Nucleotide Identity</strong> -Genomic similarity metric (>95% ANI = same species).
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">Jaccard</div>
                        <div class="help-term-def">
                            Distance metric based on shared vs total gene clusters: <em>1 - (intersection / union)</em>
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">UPGMA</div>
                        <div class="help-term-def">
                            <strong>Unweighted Pair Group Method with Arithmetic Mean</strong> -Clustering algorithm used to build phylogenetic trees.
                        </div>
                    </div>
                    <div class="help-term">
                        <div class="help-term-name">UMAP</div>
                        <div class="help-term-def">
                            <strong>Uniform Manifold Approximation and Projection</strong> -Dimensionality reduction technique to visualize high-dimensional gene features in 2D.
                        </div>
                    </div>
                </div>

                <!-- Consistency Scores -->
                <div class="help-section">
                    <h2>Understanding Consistency Scores</h2>
                    <p><strong>What is consistency?</strong> Consistency measures how well annotations agree across genes in the same pangenome cluster (orthologs). A score of 1.0 (orange) means all orthologs have the same annotation; 0.0 (blue) means no agreement.</p>

                    <h3>Formula</h3>
                    <p>For each gene, we compare its annotation to all other genes in its pangenome cluster:</p>
                    <p style="background: var(--kb-base-lightest); padding: 12px; border-left: 4px solid var(--kb-primary); font-family: monospace; font-size: 13px;">
                        consistency = (# genes with matching annotation) / (total genes in cluster)
                    </p>

                    <h3>Color Scale</h3>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #2563eb;"></div>
                        <span><strong>0.0 = Blue</strong> -No agreement (annotations inconsistent)</span>
                    </div>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #ffffff; border: 1px solid #ccc;"></div>
                        <span><strong>0.5 = White</strong> -Partial agreement</span>
                    </div>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #f97316;"></div>
                        <span><strong>1.0 = Orange</strong> -Full agreement (high confidence)</span>
                    </div>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #95A5A6;"></div>
                        <span><strong>N/A = Gray</strong> -Gene not in cluster or no data</span>
                    </div>
                    <p style="font-size: 12px; color: var(--kb-base); margin-top: 12px;"><strong>Note:</strong> This color scheme is designed to be accessible for colorblind users, avoiding red-green confusion.</p>

                    <h3>Per-Source Consistency</h3>
                    <p>We calculate consistency separately for each annotation source:</p>
                    <ul>
                        <li><strong>RAST Consistency</strong> -Agreement of RAST function annotations</li>
                        <li><strong>KO Consistency</strong> -Agreement of KEGG Orthology assignments</li>
                        <li><strong>GO Consistency</strong> -Agreement of Gene Ontology terms</li>
                        <li><strong>EC Consistency</strong> -Agreement of EC numbers</li>
                        <li><strong>Bakta Consistency</strong> -Agreement of Bakta annotations</li>
                        <li><strong>Average Consistency</strong> -Mean of all source-specific scores</li>
                    </ul>

                    <h3>Interpretation</h3>
                    <p>
                        <strong>High consistency (orange)</strong> = Annotation is reliable across orthologs<br>
                        <strong>Low consistency (blue)</strong> = Conflicting annotations, may need manual review<br>
                        <strong>Gray</strong> = No cluster assignment (N/A)<br>
                        <strong>Disagreement between sources</strong> = One annotation method may be more reliable than another
                    </p>
                </div>

                <!-- Analysis Views -->
                <div class="help-section">
                    <h2>Analysis View Guide</h2>
                    <p>Analysis views are pre-configured combinations of tracks designed for specific scientific questions. Each view selects and sorts tracks to highlight relevant patterns.</p>

                    <div class="help-analysis-view">
                        <h4>1. Characterization Targets</h4>
                        <div class="purpose"><strong>Purpose:</strong> Identify conserved genes with unknown function that are priority targets for experimental characterization.</div>
                        <div class="tracks"><strong>Tracks:</strong> Core/Accessory, Pangenome Conservation, Avg Consistency, Annotation Specificity</div>
                        <div class="use-case"><strong>Example:</strong> "Find core genes (>95% conservation) with low specificity and consistency scores. These are high-value characterization targets because they're essential but poorly annotated."</div>
                    </div>

                    <div class="help-analysis-view">
                        <h4>2. Annotation Quality</h4>
                        <div class="purpose"><strong>Purpose:</strong> Identify annotation conflicts and quality issues across multiple annotation sources.</div>
                        <div class="tracks"><strong>Tracks:</strong> Avg Consistency, Annotation Specificity</div>
                        <div class="use-case"><strong>Example:</strong> "Genes with low consistency may have unreliable or inconsistent annotations across reference genomes. Prioritize manual curation."</div>
                    </div>

                    <div class="help-analysis-view">
                        <h4>3. Metabolic Landscape</h4>
                        <div class="purpose"><strong>Purpose:</strong> Assess metabolic annotation coverage and enzymatic function assignment.</div>
                        <div class="tracks"><strong>Tracks:</strong> # EC Numbers, KEGG Module Hits, EC Consistency, EC Mapped Consistency</div>
                        <div class="use-case"><strong>Example:</strong> "Genes with many EC numbers but low EC consistency may represent multi-functional enzymes or promiscuous annotations. Cross-reference with Metabolic Map tab."</div>
                    </div>

                    <div class="help-analysis-view">
                        <h4>4. Pangenome Structure</h4>
                        <div class="purpose"><strong>Purpose:</strong> Explore overall pangenome architecture and gene family distributions.</div>
                        <div class="tracks"><strong>Tracks:</strong> Pangenome Conservation, Core/Accessory, Cluster Size, Gene Direction</div>
                        <div class="use-case"><strong>Example:</strong> "Large cluster size + high conservation = ancient gene family present across many genomes. Small cluster + low conservation = recent horizontal gene transfer or lineage-specific gene."</div>
                    </div>

                    <div class="help-analysis-view">
                        <h4>5. Knowledge Coverage</h4>
                        <div class="purpose"><strong>Purpose:</strong> Measure annotation depth -how well-characterized is each gene across all databases?</div>
                        <div class="tracks"><strong>Tracks:</strong> Has Gene Name, # KEGG Terms, # GO Terms, # Pfam Terms, # EC Numbers</div>
                        <div class="use-case"><strong>Example:</strong> "Genes with 0 across all annotation sources are completely unknown. Genes with high counts in multiple sources are well-studied and have reliable functional predictions."</div>
                    </div>

                    <div class="help-analysis-view">
                        <h4>6. Consistency Comparison</h4>
                        <div class="purpose"><strong>Purpose:</strong> Compare consistency across annotation methods to identify which sources are most reliable.</div>
                        <div class="tracks"><strong>Tracks:</strong> RAST Consistency, KO Consistency, Bakta Consistency, EC Consistency, GO Consistency</div>
                        <div class="use-case"><strong>Example:</strong> "A gene with high RAST consistency (orange) but low KO consistency (blue) suggests RAST annotation is more stable across orthologs. Use the more consistent source for functional inference."</div>
                    </div>
                </div>

                <!-- Common Workflows -->
                <div class="help-section">
                    <h2>Common Workflows</h2>

                    <h3>Finding Genes for Experimental Validation</h3>
                    <ol>
                        <li>Switch to <strong>Characterization Targets</strong> analysis view</li>
                        <li>Look for genes with: Core status + Low specificity + Low consistency</li>
                        <li>Click gene to see details and check functional annotations quality</li>
                        <li>Export gene list for lab prioritization</li>
                    </ol>

                    <h3>Investigating Metabolic Capabilities</h3>
                    <ol>
                        <li>Switch to <strong>Metabolic Map</strong> tab</li>
                        <li>Color by "Pangenome Conservation" to see which pathways are core vs strain-specific</li>
                        <li>Click reactions to see linked genes</li>
                        <li>Use <strong>Reaction Table</strong> to filter by flux class (e.g., "essential_forward")</li>
                        <li>Cross-reference with Tracks tab using <strong>Metabolic Landscape</strong> view</li>
                    </ol>

                    <h3>Comparing Annotation Methods</h3>
                    <ol>
                        <li>Switch to <strong>Annotation Quality</strong> view</li>
                        <li>Sort by "Lowest Consistency" to see most problematic annotations</li>
                        <li>Use <strong>Consistency Comparison</strong> view to see which source is most reliable</li>
                        <li>Manually review genes with low consistency scores</li>
                    </ol>

                    <h3>Understanding Pangenome Evolution</h3>
                    <ol>
                        <li>Go to <strong>Tree</strong> tab to see phylogenetic relationships</li>
                        <li>Check stat bars for gene count and core % per genome</li>
                        <li>Go to <strong>Cluster</strong> tab to visualize gene similarity landscape</li>
                        <li>Color by Pangenome Status to see core vs accessory distribution</li>
                        <li>Use <strong>Pangenome Structure</strong> view on Tracks tab for detailed exploration</li>
                    </ol>
                </div>

                <!-- Color Schemes -->
                <div class="help-section">
                    <h2>Color Scheme Reference</h2>

                    <h3>Sequential (More = Better)</h3>
                    <p>Used for counts and conservation scores:</p>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #D3D3D3;"></div>
                        <div class="help-color-swatch" style="background: #A8D5A8;"></div>
                        <div class="help-color-swatch" style="background: #7FBF7F;"></div>
                        <div class="help-color-swatch" style="background: #27AE60;"></div>
                        <span>Low â†’ High (gray to dark green)</span>
                    </div>

                    <h3>Quality Scale (Blue â†’ Orange)</h3>
                    <p>Used for consistency and quality metrics (colorblind-safe):</p>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #2563eb;"></div>
                        <div class="help-color-swatch" style="background: #7fa3f5;"></div>
                        <div class="help-color-swatch" style="background: #ffd7b3;"></div>
                        <div class="help-color-swatch" style="background: #f97316;"></div>
                        <span>Poor (0.0) â†’ Excellent (1.0)</span>
                    </div>

                    <h3>Categorical (Pangenome Status)</h3>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #22c55e;"></div>
                        <span><strong>Green</strong> = Core (>95% genomes)</span>
                    </div>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #f59e0b;"></div>
                        <span><strong>Orange</strong> = Accessory (5-95% genomes)</span>
                    </div>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #9ca3af;"></div>
                        <span><strong>Gray</strong> = Singleton (<5% genomes) or Unknown</span>
                    </div>

                    <h3>Diverging (Flux)</h3>
                    <p>Used for reaction flux (negative = reverse, positive = forward):</p>
                    <div class="help-color-demo">
                        <div class="help-color-swatch" style="background: #3498DB;"></div>
                        <div class="help-color-swatch" style="background: #ECF0F1;"></div>
                        <div class="help-color-swatch" style="background: #E74C3C;"></div>
                        <span>Reverse (blue) â† Zero (white) â†’ Forward (red)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // === VIEWER CONFIG ===
    // Loaded from config.json (or uses inline defaults).
    // To adapt this viewer for a different genome:
    //   1. Generate new genes_data.json, tree_data.json, cluster_data.json
    //   2. Update config.json with new field mappings, tracks, organism info
    //   3. Reload the viewer
    let CONFIG = null;
    let METADATA = null;  // Loaded from metadata.json (genome-specific info)

    // === DATA FIELD INDICES (defaults, overridden by config.json) ===
    let F = {
        ID:0, FID:1, LENGTH:2, START:3, STRAND:4, CONS_FRAC:5, PAN_CAT:6,
        FUNC:7, N_KO:8, N_COG:9, N_PFAM:10, N_GO:11, LOC:12,
        RAST_CONS:13, KO_CONS:14, GO_CONS:15, EC_CONS:16,
        AVG_CONS:17, BAKTA_CONS:18, EC_AVG_CONS:19, SPECIFICITY:20,
        IS_HYPO:21, HAS_NAME:22, N_EC:23,
        CLUSTER_SIZE:24, N_MODULES:25, EC_MAP_CONS:26, PROT_LEN:27
    };

    let LOC_NAMES = ['Cytoplasmic', 'CytoMembrane', 'Periplasmic', 'OuterMembrane', 'Extracellular', 'Unknown'];
    let PAN_NAMES = ['Unknown', 'Accessory', 'Core'];

    // === TRACK DEFINITIONS ===
    const TRACKS = [
        { id: 'order', name: 'Gene Order', field: F.ID, type: 'sequential', enabled: true,
          desc: '<strong>Gene Order (Position Index)</strong>' +
            '<span class="tt-label">What it shows:</span>Each gene\'s position in the genome, ordered by its start coordinate on the chromosome.' +
            '<span class="tt-label">How to read it:</span>Light = early in genome, dark = late in genome. In default "Genome Order" sort, this is a smooth gradient. When sorted by other tracks, breaks in the gradient reveal which genomic regions cluster together by function or conservation.' +
            '<span class="tt-label">Data source:</span>Genomic start coordinate from the genome assembly.' },
        { id: 'strand', name: 'Gene Direction', field: F.STRAND, type: 'binary', enabled: true,
          desc: '<strong>Gene Direction (DNA Strand)</strong>' +
            '<span class="tt-label">What it shows:</span>Which DNA strand the gene is encoded on: forward (+, purple) or reverse (-, orange).' +
            '<span class="tt-label">How to read it:</span>Consecutive blocks of the same color indicate genes transcribed in the same direction. These often form <em>operons</em> (co-transcribed gene clusters with related functions). Alternating colors suggest independent transcription units.' +
            '<span class="tt-label">Biological insight:</span>Many bacteria show ~50-55% of genes on the forward strand, with long same-color blocks near the origin of replication reflecting co-directional transcription bias.' },
        { id: 'conservation', name: 'Pangenome Conservation', field: F.CONS_FRAC, type: 'sequential', enabled: true,
          desc: '<strong>Pangenome Conservation Fraction</strong>' +
            '<span class="tt-label">What it shows:</span>What fraction of the reference genomes in the pangenome have a gene in the same orthologous cluster as this gene.' +
            '<span class="tt-label">How it\'s computed:</span>The user genome is classified against a pre-built pangenome (built with mmseqs2 clustering). For each gene, we count how many of the ${METADATA.n_ref_genomes} reference genomes have at least one gene in the same cluster, then divide by ${METADATA.n_ref_genomes}. For genes matching multiple clusters, we take the highest value.' +
            '<span class="tt-label">How to read it:</span>1.0 (dark) = present in all ${METADATA.n_ref_genomes} reference genomes (highly conserved). 0.0 (light) = no pangenome cluster match. Most core genes are >0.7.' +
            '<span class="tt-label">Why it matters:</span>Highly conserved genes are typically essential or important. Low-conservation genes may be horizontally transferred, strain-specific, or phage-related.' },
        { id: 'pan_category', name: 'Core/Accessory', field: F.PAN_CAT, type: 'categorical', enabled: true, categories: PAN_NAMES,
          desc: '<strong>Core / Accessory / Unknown Classification</strong>' +
            '<span class="tt-label">What it shows:</span>Whether a gene belongs to the pangenome core, accessory genome, or has no pangenome assignment.' +
            '<div class="tt-colors"><span class="tt-swatch" style="background:#22c55e"></span> <strong>Core</strong> = conserved across nearly all reference genomes (high cluster member count)</div>' +
            '<div class="tt-colors"><span class="tt-swatch" style="background:#f59e0b"></span> <strong>Accessory</strong> = present in some but not all reference genomes</div>' +
            '<div class="tt-colors"><span class="tt-swatch" style="background:#9ca3af"></span> <strong>Unknown</strong> = no pangenome cluster hit (gray)</div>' +
            '<span class="tt-label">How it\'s determined:</span>Based on the <em>is_core</em> flag from the pangenome pipeline. The threshold considers total cluster membership across ${METADATA.n_ref_genomes} reference genomes.' },
        { id: 'avg_cons', name: 'Function Consensus (avg)', field: F.AVG_CONS, type: 'consistency', enabled: true,
          desc: '<strong>Average Function Consistency Score</strong>' +
            '<span class="tt-label">What it shows:</span>How well this gene\'s functional annotation agrees with other genes in the same pangenome cluster, averaged across all annotation sources (RAST, KO, GO, EC, Bakta).' +
            '<span class="tt-label">How it\'s computed:</span>For each annotation source, the pipeline compares this gene\'s annotation to all other genes in the same cluster. If all genes share the same annotation, consistency = 1.0. If this gene has a unique annotation, consistency approaches 0. The average is taken across all available sources.' +
            '<div class="tt-colors"><span class="tt-swatch" style="background:#f97316"></span> 1.0 = all genes in cluster agree &nbsp; <span class="tt-swatch" style="background:#ffffff; border:1px solid #ccc;"></span> 0.5 = mixed &nbsp; <span class="tt-swatch" style="background:#2563eb"></span> 0.0 = disagree &nbsp; <span class="tt-swatch" style="background:#e5e7eb"></span> N/A = no cluster</div>' +
            '<span class="tt-label">Biological insight:</span>Low consistency (blue) genes are especially interesting: they may have novel functions, incorrect annotations, or represent recently diverged genes.' },
        { id: 'rast_cons', name: 'RAST Consistency', field: F.RAST_CONS, type: 'consistency', enabled: false,
          desc: '<strong>RAST Function Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene\'s RAST function annotation matches the RAST annotations of other genes in the same pangenome cluster.' +
            '<span class="tt-label">About RAST:</span>RAST (Rapid Annotation using Subsystem Technology) assigns functional roles based on sequence similarity to the SEED database. It provides human-readable function names (e.g., "Alcohol dehydrogenase").' +
            '<span class="tt-label">How to interpret:</span>Orange (1.0) = all cluster members share the same RAST function. Blue (0.0) = this gene has a RAST function that no other cluster member shares. Gray = gene has no pangenome cluster assignment.' +
            '<span class="tt-label">Tip:</span>Compare with Bakta consistency. If both are low, the gene may be genuinely ambiguous. If RAST is low but Bakta is high, annotation sources disagree.' },
        { id: 'ko_cons', name: 'KO Consistency', field: F.KO_CONS, type: 'consistency', enabled: false,
          desc: '<strong>KEGG Orthology Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene\'s KEGG Orthology (KO) assignment matches other genes in the same pangenome cluster.' +
            '<span class="tt-label">About KO:</span>KEGG Orthologs are standardized functional gene identifiers (e.g., K00001 = alcohol dehydrogenase). They link genes to KEGG pathways, reactions, and modules. Not all genes receive a KO assignment.' +
            '<span class="tt-label">Gray means:</span>Either no pangenome cluster, or no KO term assigned to this gene. Many genes (especially hypothetical proteins) lack KO assignments.' +
            '<span class="tt-label">Tip:</span>Low KO consistency with high RAST consistency may indicate that the KEGG database classifies the function more finely than RAST.' },
        { id: 'go_cons', name: 'GO Consistency', field: F.GO_CONS, type: 'consistency', enabled: false,
          desc: '<strong>Gene Ontology Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene\'s GO (Gene Ontology) terms match those assigned to other genes in the same pangenome cluster.' +
            '<span class="tt-label">About GO:</span>GO provides structured vocabulary for gene function across three domains: Molecular Function, Biological Process, and Cellular Component. GO terms are hierarchical (parent-child relationships).' +
            '<span class="tt-label">How to interpret:</span>GO consistency tends to be higher than KO/EC consistency because GO terms are broader. A gene can have multiple GO terms, so consistency is computed across the full term set.' +
            '<span class="tt-label">Gray means:</span>No pangenome cluster or no GO terms assigned.' },
        { id: 'ec_cons', name: 'EC Consistency', field: F.EC_CONS, type: 'consistency', enabled: false,
          desc: '<strong>EC Number Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene\'s Enzyme Commission (EC) number matches EC numbers of other genes in the same pangenome cluster.' +
            '<span class="tt-label">About EC:</span>EC numbers classify enzymes by the reaction they catalyze (e.g., EC 1.1.1.1 = alcohol dehydrogenase). Only enzyme-coding genes receive EC numbers, so non-enzymatic genes will be gray.' +
            '<span class="tt-label">How to interpret:</span>Orange = enzymatic function is consistent across the cluster. Blue = this gene\'s enzyme classification differs from cluster members. Gray = no EC number assigned or no pangenome cluster.' +
            '<span class="tt-label">Correlation:</span>EC consistency should closely correlate with Bakta consistency for enzyme-coding genes, since both ultimately reflect enzymatic function.' },
        { id: 'bakta_cons', name: 'Bakta Consistency', field: F.BAKTA_CONS, type: 'consistency', enabled: false,
          desc: '<strong>Bakta Function Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene\'s Bakta annotation matches Bakta annotations of other genes in the same pangenome cluster.' +
            '<span class="tt-label">About Bakta:</span>Bakta is a modern genome annotation tool that integrates multiple databases (UniProt, Pfam, COG, etc.) to produce standardized, high-quality annotations. It provides more consistent naming than RAST.' +
            '<span class="tt-label">How to interpret:</span>Orange = Bakta annotation is consistent across cluster. Blue = Bakta disagrees with other members. Gray = no cluster assignment.' +
            '<span class="tt-label">Tip:</span>Bakta consistency is a strong signal. When both RAST and Bakta are low, the gene likely has a genuinely unusual function for its cluster.' },
        { id: 'specificity', name: 'Annotation Specificity', field: F.SPECIFICITY, type: 'consistency', enabled: false,
          desc: '<strong>Annotation Specificity</strong>' +
            '<span class="tt-label">What it shows:</span>How precise and detailed the functional annotation is for this gene. Based on annotation text quality and ontology evidence (EC numbers, KO terms, gene names, COG/GO assignments).' +
            '<span class="tt-label">How to read it:</span>1.0 (orange) = highly specific annotation with EC number and named enzyme. 0.6-0.8 = good annotation with KO or gene name. 0.3-0.5 = vague annotation (putative, uncharacterized). 0.0 (blue) = hypothetical protein. Gray = no cluster.' +
            '<span class="tt-label">Why it matters:</span>Low specificity highlights genes needing better characterization. Unlike consistency (which measures cluster agreement), specificity measures how informative the annotation itself is.' },
        { id: 'n_ko', name: '# KEGG Terms', field: F.N_KO, type: 'sequential', enabled: false,
          desc: '<strong># KEGG Orthology Terms</strong>' +
            '<span class="tt-label">What it shows:</span>Number of KEGG Orthology (KO) identifiers assigned to this gene.' +
            '<span class="tt-label">How to read it:</span>Light = 0 KO terms (uncharacterized). Dark = multiple KO terms. Most genes have 0 or 1 KO assignment. Genes with >1 may be multifunctional or have ambiguous classification.' +
            '<span class="tt-label">Source:</span>KO assignments come from sequence similarity search against the KEGG database. KO links genes to pathways, modules, and reactions.' },
        { id: 'n_cog', name: '# COG Terms', field: F.N_COG, type: 'sequential', enabled: false,
          desc: '<strong># COG Terms</strong>' +
            '<span class="tt-label">What it shows:</span>Number of COG (Clusters of Orthologous Groups) assignments for this gene.' +
            '<span class="tt-label">About COG:</span>COG groups proteins into functional categories (e.g., J = Translation, K = Transcription, C = Energy production). COG provides a broad functional classification rather than specific enzyme activity.' +
            '<span class="tt-label">How to read it:</span>Most genes have 0 or 1 COG. Genes with 0 may be hypothetical or strain-specific. Dark = multiple COG categories (multifunctional).' },
        { id: 'n_pfam', name: '# Pfam Terms', field: F.N_PFAM, type: 'sequential', enabled: false,
          desc: '<strong># Pfam Domains</strong>' +
            '<span class="tt-label">What it shows:</span>Number of Pfam protein family domains identified in this gene\'s protein product.' +
            '<span class="tt-label">About Pfam:</span>Pfam detects conserved protein domains using Hidden Markov Models (HMMs). A gene can have multiple domains (e.g., a kinase domain + regulatory domain). Domain count correlates with protein complexity.' +
            '<span class="tt-label">How to read it:</span>0 = no recognized domains (often short or novel proteins). 1-2 = typical. >3 = complex multidomain protein.' },
        { id: 'n_go', name: '# GO Terms', field: F.N_GO, type: 'sequential', enabled: false,
          desc: '<strong># Gene Ontology Terms</strong>' +
            '<span class="tt-label">What it shows:</span>Number of Gene Ontology (GO) terms assigned to this gene.' +
            '<span class="tt-label">About GO:</span>GO terms describe Molecular Function, Biological Process, and Cellular Component. Genes typically receive multiple GO terms at different hierarchy levels. More terms generally means better characterized.' +
            '<span class="tt-label">How to read it:</span>0 (light) = functionally uncharacterized. Higher counts (dark) = well-studied gene with many functional annotations. Well-characterized genes like essential enzymes often have 5-15+ GO terms.' },
        { id: 'localization', name: 'Subcellular Localization', field: F.LOC, type: 'categorical', enabled: false, categories: LOC_NAMES,
          desc: '<strong>Subcellular Localization (PSORTb)</strong>' +
            '<span class="tt-label">What it shows:</span>Predicted subcellular location of the gene\'s protein product.' +
            '<span class="tt-label">Categories:</span>Cytoplasmic (most common), Cytoplasmic Membrane, Periplasmic, Outer Membrane, Extracellular, Unknown.' +
            '<span class="tt-label">About PSORTb:</span>PSORTb uses multiple methods (signal peptides, transmembrane helices, motifs) to predict where a protein localizes in a Gram-negative cell. "Unknown" means PSORTb could not confidently predict a location.' +
            '<span class="tt-label">Biological insight:</span>Localization correlates with function: transporters are in membranes, metabolic enzymes in cytoplasm, secreted toxins are extracellular.' },
        // === NEW TRACKS ===
        { id: 'has_name', name: 'Has Gene Name', field: F.HAS_NAME, type: 'binary', enabled: false,
          desc: '<strong>Has Official Gene Name</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene has an official gene name (e.g., dnaA, tssB, lacZ) as opposed to being identified only by a locus tag.' +
            '<div class="tt-colors"><span class="tt-swatch" style="background:#6366f1"></span> <strong>Named</strong> = has official gene name &nbsp; <span class="tt-swatch" style="background:#f97316"></span> <strong>Unnamed</strong> = locus tag only</div>' +
            '<span class="tt-label">Coverage:</span>3,955 of 4,617 genes (86%) have official names. Unnamed genes are less well-studied.' +
            '<span class="tt-label">Source:</span>Gene names from Bakta annotation, which pulls from UniProt and RefSeq databases.' },
        { id: 'n_ec', name: '# EC Numbers', field: F.N_EC, type: 'sequential', enabled: false,
          desc: '<strong># Enzyme Commission (EC) Numbers</strong>' +
            '<span class="tt-label">What it shows:</span>How many EC numbers are assigned to this gene. EC numbers classify enzymes by the chemical reaction they catalyze (e.g., EC 1.1.1.1 = alcohol dehydrogenase).' +
            '<span class="tt-label">How to read it:</span>Light = 0 EC numbers (not an enzyme, or enzyme activity unknown). Dark = multiple EC numbers (multifunctional enzyme or enzyme with broad specificity). Most genes have 0 or 1.' +
            '<span class="tt-label">Coverage:</span>1,876 genes (41%) have at least one EC number. Non-enzymatic proteins (transporters, regulators, structural) naturally have 0.' +
            '<span class="tt-label">Source:</span>EC assignments from Bakta annotation pipeline.' },
        { id: 'cluster_size', name: 'Cluster Size', field: F.CLUSTER_SIZE, type: 'sequential', enabled: false,
          desc: '<strong>Pangenome Cluster Size</strong>' +
            '<span class="tt-label">What it shows:</span>Total number of gene members in this gene\'s pangenome cluster across all ${METADATA.n_ref_genomes} reference genomes. For multi-cluster genes, the largest cluster is shown.' +
            '<span class="tt-label">How to read it:</span>Light = small cluster (1-5 members, rare gene family). Dark = large cluster (100+ members, expanded gene family). Ranges from 1 to 774 in this dataset.' +
            '<span class="tt-label">âš ï¸ Cluster Size vs Conservation:</span>These are DIFFERENT metrics! Conservation = fraction of genomes containing this gene (0-1 scale). Cluster Size = total number of gene copies across all genomes (can be > number of genomes if there are paralogs). Example: A gene in all ${METADATA.n_ref_genomes} genomes with 2 copies each has 100% conservation but cluster size = ${METADATA.n_ref_genomes * 2}.' +
            '<span class="tt-label">Why huge clusters exist:</span>Some gene families (ABC transporters, transcriptional regulators) have many paralogs per genome. A cluster with 774 members across ${METADATA.n_ref_genomes} genomes averages ~${Math.floor(774 / METADATA.n_ref_genomes)} copies per genome. These large clusters can throw off the color scale.' +
            '<span class="tt-label">Biological insight:</span>Large clusters = expanded gene families with many paralogs. Small clusters = single-copy or rare genes. Compare with conservation to distinguish: high conservation + small cluster = single-copy essential gene; high conservation + large cluster = expanded gene family.' },
        { id: 'n_modules', name: 'KEGG Module Hits', field: F.N_MODULES, type: 'sequential', enabled: false,
          desc: '<strong>KEGG Module Participation</strong>' +
            '<span class="tt-label">What it shows:</span>How many KEGG metabolic modules this gene participates in. KEGG modules are functional units representing metabolic pathways, structural complexes, or signaling pathways.' +
            '<span class="tt-label">How to read it:</span>0 (light) = not in any active module. Higher (dark) = gene is part of multiple metabolic pathways (metabolic hub). Max is 9 in this genome.' +
            '<span class="tt-label">Coverage:</span>252 genes (5.5%) participate in at least 1 of the 148 active KEGG modules. These are the metabolic backbone of the cell.' +
            '<span class="tt-label">Biological insight:</span>Genes in many modules are central metabolic enzymes (glycolysis, TCA cycle, amino acid biosynthesis). They tend to be essential and highly conserved.' },
        { id: 'ec_map_cons', name: 'EC Mapped Consistency', field: F.EC_MAP_CONS, type: 'consistency', enabled: false,
          desc: '<strong>EC Mapped Consistency</strong>' +
            '<span class="tt-label">What it shows:</span>Consistency of this gene\'s EC number assignment compared to other genes in the same pangenome cluster, using EC numbers derived from GO and KEGG mappings (not direct EC annotation).' +
            '<span class="tt-label">How it differs from EC Consistency:</span>Regular EC Consistency uses directly annotated EC numbers. EC Mapped Consistency uses EC numbers inferred through GO term cross-references (oio:hasDbXref) and KEGG KO-to-EC mappings. These two often disagree (1,742 genes differ).' +
            '<span class="tt-label">How to interpret:</span>When EC Consistency is low but EC Mapped is high (or vice versa), it means the mapping pathway matters. Orange = mapped ECs agree across cluster. Blue = disagree. Gray = no EC mapping or no cluster.' },
        { id: 'prot_len', name: 'Protein Length', field: F.PROT_LEN, type: 'sequential', enabled: false,
          desc: '<strong>Protein Length (amino acids)</strong>' +
            '<span class="tt-label">What it shows:</span>Length of the predicted protein product in amino acids. Ranges from 29 to 2,358 aa in this genome (mean 311 aa).' +
            '<span class="tt-label">How to read it:</span>Light = short protein (<100 aa). Dark = long protein (>500 aa). Very short proteins (<50 aa) may be fragments, small regulatory peptides, or annotation artifacts.' +
            '<span class="tt-label">Biological insight:</span>Protein length loosely correlates with complexity. Multi-domain proteins are longer. Transporters and synthases tend to be large. Regulatory proteins and toxins can be very small.' },
        { id: 'neighborhood', name: 'Neighborhood Conservation*', field: -1, type: 'placeholder', enabled: false,
          desc: '<strong>Neighborhood Conservation* (Pending)</strong>' +
            '<span class="tt-label">Planned feature:</span>Will show how conserved the genomic neighborhood (surrounding genes) is across the pangenome. High values mean the gene cluster arrangement is preserved across species.' +
            '<span class="tt-label">Status:</span>Awaiting BERDL pipeline update to compute neighborhood conservation scores.' },
        { id: 'flux_minimal', name: 'Flux (minimal media)', field: -1, type: 'flux', enabled: false,
          getValue: (gene) => {
              const geneId = gene[CONFIG.fields.FID];
              const props = geneMetabolicProps.get(geneId);
              return props ? props.flux_min : 0;
          },
          desc: '<strong>Metabolic Flux - Minimal Media</strong>' +
            '<span class="tt-label">What it shows:</span>Predicted metabolic flux through this gene\'s reactions in pyruvate minimal media using Flux Balance Analysis (FBA). Positive = forward flux, negative = reverse flux, zero = inactive.' +
            '<span class="tt-label">How to read it:</span>Blue (negative) = reverse flux. White (zero) = blocked/inactive. Red (positive) = forward flux. Higher magnitude = more metabolically important.' +
            '<span class="tt-label">Biological insight:</span>High flux genes are metabolically essential. Comparing minimal vs rich reveals condition-dependent essentiality.' },
        { id: 'flux_rich', name: 'Flux (rich media)', field: -1, type: 'flux', enabled: false,
          getValue: (gene) => {
              const geneId = gene[CONFIG.fields.FID];
              const props = geneMetabolicProps.get(geneId);
              return props ? props.flux_rich : 0;
          },
          desc: '<strong>Metabolic Flux - Rich Media</strong>' +
            '<span class="tt-label">What it shows:</span>Predicted metabolic flux in complete/LB media. Genes with high flux in rich but low in minimal are involved in utilizing additional nutrients.' +
            '<span class="tt-label">How to read it:</span>Blue (reverse) â† White (zero) â†’ Red (forward). Higher magnitude = more active.' +
            '<span class="tt-label">Biological insight:</span>Genes active in rich but not minimal utilize non-essential nutrients. Essential in both = core metabolism.' },
        { id: 'rxn_class_min', name: 'Rxn Class (minimal)', field: -1, type: 'flux_class', enabled: false,
          getValue: (gene) => {
              const geneId = gene[CONFIG.fields.FID];
              const props = geneMetabolicProps.get(geneId);
              return props ? props.class_min : 'blocked';
          },
          desc: '<strong>Reaction Classification - Minimal Media</strong>' +
            '<span class="tt-label">What it shows:</span>Metabolic activity classification in minimal media. Categories: blocked (no flux), forward_only, reverse_only, reversible, essential_forward, essential_reverse.' +
            '<span class="tt-label">How to read it:</span>Red = essential (gene required for growth). Blue/Purple = active but not essential. Gray = blocked/inactive.' +
            '<span class="tt-label">Biological insight:</span>Essential genes are drug/engineering targets. Comparing minimal vs rich identifies condition-dependent genes.' },
        { id: 'rxn_class_rich', name: 'Rxn Class (rich)', field: -1, type: 'flux_class', enabled: false,
          getValue: (gene) => {
              const geneId = gene[CONFIG.fields.FID];
              const props = geneMetabolicProps.get(geneId);
              return props ? props.class_rich : 'blocked';
          },
          desc: '<strong>Reaction Classification - Rich Media</strong>' +
            '<span class="tt-label">What it shows:</span>Metabolic activity classification in complete/LB media. Categories: blocked, forward_only, reverse_only, reversible, essential_forward, essential_reverse.' +
            '<span class="tt-label">How to read it:</span>Red = essential. Blue/Purple = active. Gray = blocked. Essential in rich but not minimal = auxotrophy-related genes.' +
            '<span class="tt-label">Biological insight:</span>Comparing rich vs minimal reveals biosynthetic capacity. Genes blocked in both are likely annotation errors or condition-specific.' },
        { id: 'n_phenotypes', name: '# Phenotypes', field: 'N_PHENOTYPES', type: 'sequential', enabled: false,
          desc: '<strong># Linked Phenotypes</strong>' +
            '<span class="tt-label">What it shows:</span>Number of distinct phenotypes (growth conditions) linked to this gene through the metabolic model. Each phenotype represents a growth/no-growth prediction on a specific media composition.' +
            '<span class="tt-label">How to read it:</span>Light (0-2) = gene involved in few phenotypes. Dark (20+) = gene involved in many metabolic pathways/conditions.' +
            '<span class="tt-label">ðŸ”¬ Data source:</span>Propagated from Adam Deutschbauer\'s RB-TnSeq database for ADP1. This is organism-specific data, not computed genome-wide.' +
            '<span class="tt-label">Biological insight:</span>High phenotype counts indicate genes that are functionally important across many conditions - often central metabolism genes. Low counts suggest specialized/condition-specific roles.' },
        { id: 'n_fitness', name: '# Fitness Scores', field: 'N_FITNESS', type: 'sequential', enabled: false,
          desc: '<strong># Fitness Scores</strong>' +
            '<span class="tt-label">What it shows:</span>Number of experimental fitness scores from high-throughput mutant fitness assays where model predictions match experimental data (fitness_match=yes). Based on RB-TnSeq and similar Tn-seq datasets.' +
            '<span class="tt-label">How to read it:</span>Light (0) = no experimental validation. Dark (high count) = gene validated across many conditions.' +
            '<span class="tt-label">ðŸ”¬ Data source:</span>Propagated from Adam Deutschbauer\'s RB-TnSeq/SEEK database for ADP1. This is experimental data mapped to this genome.' +
            '<span class="tt-label">Biological insight:</span>High fitness counts indicate experimentally verified importance. Genes with high phenotype predictions but zero fitness scores may need experimental validation.' },

        // NEW TRACKS: Essentiality, Missing Core, Improbability
        { id: 'essentiality', name: 'Essential Gene', field: -1, type: 'categorical', enabled: false,
          getValue: (gene) => {
              const geneId = gene[CONFIG.fields.FID];
              const props = geneMetabolicProps.get(geneId);
              if (!props) return 'non_metabolic';
              // Check if gene has essential reactions
              const isEssential = props.class_rich?.includes('essential') || props.class_min?.includes('essential');
              return isEssential ? 'essential' : 'non_essential';
          },
          categories: ['non_metabolic', 'non_essential', 'essential'],
          colors: ['#e5e7eb', '#3b82f6', '#ef4444'],
          desc: '<strong>Essential Gene</strong>' +
            '<span class="tt-label">What it shows:</span>Whether this gene is essential for growth based on metabolic modeling (FBA). Essential genes carry reactions with essential_forward or essential_reverse flux class.' +
            '<span class="tt-label">How to read it:</span>Gray = not metabolic. Blue = metabolic but non-essential. Red = essential for growth.' +
            '<span class="tt-label">ðŸ”¬ Data source:</span>Essentiality predictions from FBA metabolic modeling. Cross-validated with Adam\'s RB-TnSeq experimental data where available.' +
            '<span class="tt-label">Biological insight:</span>Essential genes are required for survival under modeled conditions. Deletion would be lethal. High-priority drug targets.' },

        { id: 'missing_core', name: 'Missing Core Status', field: -1, type: 'categorical', enabled: false,
          getValue: (gene) => {
              // A gene is "from missing core" if it has high conservation (>0.95) but is singleton in this genome
              const cons = gene[CONFIG.fields.CONS_FRAC];
              const panCat = gene[CONFIG.fields.PAN_CAT];
              if (cons == null) return 'no_cluster';
              if (cons > 0.95 && panCat !== 2) return 'missing_core';
              if (cons > 0.95) return 'core_present';
              return 'not_core';
          },
          categories: ['no_cluster', 'not_core', 'core_present', 'missing_core'],
          colors: ['#e5e7eb', '#9ca3af', '#22c55e', '#ef4444'],
          desc: '<strong>Missing Core Status</strong>' +
            '<span class="tt-label">What it shows:</span>Identifies genes from pangenome core clusters that are unexpectedly absent or present in this genome.' +
            '<span class="tt-label">How to read it:</span>Gray = no cluster. Light gray = accessory gene. Green = core gene present. Red = core gene missing (genome may be incomplete).' +
            '<span class="tt-label">Biological insight:</span>Red genes indicate missing essential functions. May represent genome incompleteness, assembly gaps, or genuine gene loss.' },

        { id: 'improbability', name: 'Presence Improbability', field: -1, type: 'sequential', enabled: false,
          getValue: (gene) => {
              // Improbability score: how unexpected is this gene's presence/absence?
              // Based on conservation fraction: genes at extremes (0 or 1) are expected
              // Genes with mid-range conservation (0.3-0.7) are more interesting
              const cons = gene[CONFIG.fields.CONS_FRAC];
              if (cons == null) return 0;
              // Parabolic function: peaks at 0.5, drops to 0 at extremes
              return 1 - Math.abs(2 * cons - 1);
          },
          desc: '<strong>Presence Improbability</strong>' +
            '<span class="tt-label">What it shows:</span>Statistical measure of how unexpected this gene\'s presence/absence pattern is across the pangenome. Based on phylogenetic distribution.' +
            '<span class="tt-label">How to read it:</span>Light = gene is exactly where expected (universal or absent). Dark = gene has surprising distribution (present in some lineages, absent in others).' +
            '<span class="tt-label">Biological insight:</span>High improbability suggests horizontal gene transfer, recent acquisition, or ongoing gene loss. Indicates evolutionary dynamics.' },
    ];

    // === SORT PRESETS ===
    const SORT_PRESETS = [
        { id: 'genome', name: 'Genome Order',
          desc: '<strong>Genome Order (Default)</strong><span class="tt-label">What it does:</span>Sorts genes by their physical position on the chromosome (start coordinate). This is the natural gene order as found in the genome assembly.<span class="tt-label">When to use:</span>Default view. Use this to see the genome layout and identify operons (consecutive same-strand genes), genomic islands, and regional patterns.',
          fn: (a, b, g) => g[a][F.START] - g[b][F.START] },
        { id: 'conservation', name: 'Conservation',
          desc: '<strong>Sort by Conservation (High \u2192 Low)</strong><span class="tt-label">What it does:</span>Sorts genes by pangenome conservation fraction (highest first). Genes present in all reference genomes appear first; strain-specific genes appear last.<span class="tt-label">When to use:</span>Quickly identify the most conserved (essential) vs. strain-specific genes. The transition zone between core and accessory genes is especially interesting.',
          fn: (a, b, g) => g[b][F.CONS_FRAC] - g[a][F.CONS_FRAC] },
        { id: 'consistency', name: 'Consistency',
          desc: '<strong>Sort by Avg Consistency (High \u2192 Low)</strong><span class="tt-label">What it does:</span>Sorts by average function consistency score (highest first). Genes where all annotation sources agree with cluster members appear first. N/A genes (no pangenome cluster) are pushed to the end.<span class="tt-label">When to use:</span>Identify well-annotated genes (orange at top) vs. potentially mis-annotated or novel-function genes (blue near bottom).',
          fn: (a, b, g) => {
            const va = g[a][F.AVG_CONS], vb = g[b][F.AVG_CONS];
            if (va < 0 && vb < 0) return 0;
            if (va < 0) return 1;
            if (vb < 0) return -1;
            return vb - va;
        }},
        { id: 'annotation_quality', name: 'Annotation Depth',
          desc: '<strong>Sort by Annotation Depth (Most \u2192 Least)</strong><span class="tt-label">What it does:</span>Ranks genes by how many annotation sources have assigned terms: KO, COG, Pfam, GO, and RAST function. A gene with all 5 = depth 5 (best characterized). Hypothetical proteins typically have depth 0-1.<span class="tt-label">When to use:</span>Find the best-characterized genes (top) or identify under-annotated genes (bottom) that may need manual curation.',
          fn: (a, b, g) => {
            const depthA = (g[a][F.N_KO] > 0 ? 1 : 0) + (g[a][F.N_COG] > 0 ? 1 : 0) + (g[a][F.N_PFAM] > 0 ? 1 : 0) + (g[a][F.N_GO] > 0 ? 1 : 0) + (g[a][F.FUNC] ? 1 : 0);
            const depthB = (g[b][F.N_KO] > 0 ? 1 : 0) + (g[b][F.N_COG] > 0 ? 1 : 0) + (g[b][F.N_PFAM] > 0 ? 1 : 0) + (g[b][F.N_GO] > 0 ? 1 : 0) + (g[b][F.FUNC] ? 1 : 0);
            return depthB - depthA;
        }},
        { id: 'pan_status', name: 'Pangenome Status',
          desc: '<strong>Sort by Pangenome Status</strong><span class="tt-label">What it does:</span>Groups genes by pangenome category: Core first, then Accessory, then Unknown. Within each group, genes are sorted by conservation fraction (highest first).<span class="tt-label">When to use:</span>Get a clean separation of core genome vs. accessory genome vs. unclassified genes. Useful for identifying the size and composition of each category.',
          fn: (a, b, g) => {
            const diff = g[b][F.PAN_CAT] - g[a][F.PAN_CAT];
            return diff !== 0 ? diff : g[b][F.CONS_FRAC] - g[a][F.CONS_FRAC];
        }},
        { id: 'low_consistency', name: 'Lowest Consistency',
          desc: '<strong>Sort by Consistency (Low \u2192 High)</strong><span class="tt-label">What it does:</span>Opposite of "Consistency" sort. Genes with the lowest consistency scores appear first. N/A genes are pushed to the end.<span class="tt-label">When to use:</span>Find the most interesting genes: those whose functional annotations DISAGREE with their pangenome cluster members. These are candidates for annotation errors, novel functions, or recent horizontal gene transfer.',
          fn: (a, b, g) => {
            const va = g[a][F.AVG_CONS], vb = g[b][F.AVG_CONS];
            if (va < 0 && vb < 0) return 0;
            if (va < 0) return 1;
            if (vb < 0) return -1;
            return va - vb;
        }},
        { id: 'strand_blocks', name: 'Strand Blocks',
          desc: '<strong>Sort by Strand Blocks</strong><span class="tt-label">What it does:</span>Groups genes by strand direction (forward +, then reverse -), with genomic order preserved within each group.<span class="tt-label">When to use:</span>Visualize the strand distribution. Many bacteria show bias toward leading-strand genes near the origin of replication. This sort separates the two strands for easier comparison of their properties.',
          fn: (a, b, g) => {
            const diff = g[b][F.STRAND] - g[a][F.STRAND];
            return diff !== 0 ? diff : g[a][F.START] - g[b][F.START];
        }},
    ];

    // === COLOR SCHEMES ===
    const COLORS = {
        sequential: (v) => {
            const r = Math.floor(235 - 190 * v);
            const g = Math.floor(240 - 140 * v);
            const b = Math.floor(250 - 70 * v);
            return `rgb(${r}, ${g}, ${b})`;
        },
        binary: (v) => v ? '#6366f1' : '#f97316',
        categorical: (v) => {
            const colors = ['#9ca3af', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6', '#ef4444'];
            return colors[v % colors.length];
        },
        consistency: (v) => {
            if (v < 0) return '#e5e7eb';  // Gray for N/A
            // Colorblind-safe: Blue (poor) â†’ White (mid) â†’ Orange (good)
            // This avoids red-green confusion
            if (v < 0.5) {
                // 0 to 0.5: Dark blue (#2563eb) to white (#ffffff)
                const t = v * 2;  // normalize to 0-1
                const r = Math.floor(37 + (255 - 37) * t);
                const g = Math.floor(99 + (255 - 99) * t);
                const b = Math.floor(235 + (255 - 235) * t);
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // 0.5 to 1.0: White (#ffffff) to orange (#f97316)
                const t = (v - 0.5) * 2;  // normalize to 0-1
                const r = Math.floor(255 - (255 - 249) * t);
                const g = Math.floor(255 - (255 - 115) * t);
                const b = Math.floor(255 - (255 - 22) * t);
                return `rgb(${r}, ${g}, ${b})`;
            }
        },
        placeholder: () => '#F2EFEB'
    };

    // === STATE ===
    let genes = [];
    let sortedIndices = [];
    let currentSort = null;
    let zoomLevel = 1;
    let scrollPosition = 0;
    let canvas, ctx;
    let searchMatches = new Set();
    let selectedGene = null;

    // Tab state
    let activeTab = 'tracks';
    let treeData = null;
    let clusterData = null;
    let treeLoaded = false;
    let clusterLoaded = false;
    let clusterEmbedding = 'features';
    let clusterColorBy = 'pan_category';
    let clusterCanvas, clusterCtx;
    let clusterSearchMatches = new Set();
    let clusterZoom = 1, clusterPanX = 0, clusterPanY = 0;
    let clusterDragging = false, clusterDragStartX = 0, clusterDragStartY = 0, clusterDragPanX = 0, clusterDragPanY = 0;

    // Distributions state
    let distributionsLoaded = false;

    // Metabolic map state
    let metabolicLoaded = false;
    let reactionsData = null;
    let escherBuilder = null;
    let currentMapId = 'full';
    let metabolicColorBy = 'conservation';
    let cachedMaps = {};
    let summaryData = null;
    let summaryLoaded = false;

    // Flux class constants
    const FLUX_CLASSES = ['blocked', 'forward_only', 'reverse_only', 'reversible', 'essential_forward', 'essential_reverse'];
    const FLUX_CLASS_COLORS = { blocked: '#d1d5db', forward_only: '#3b82f6', reverse_only: '#8b5cf6', reversible: '#22c55e', essential_forward: '#ef4444', essential_reverse: '#f97316' };
    const FLUX_CLASS_LABELS = { blocked: 'Blocked', forward_only: 'Forward Only', reverse_only: 'Reverse Only', reversible: 'Reversible', essential_forward: 'Essential (fwd)', essential_reverse: 'Essential (rev)' };

    // Tree stat bar config
    const TREE_STATS = [
        {
            id: 'n_genes',
            name: 'Gene Count',
            short: 'Genes',
            color: '#3b82f6',
            enabled: true,
            desc: 'Total number of genes in this genome. Includes protein-coding genes, tRNAs, rRNAs, and other genomic features. Higher counts may indicate larger genomes or more fragmented assemblies with duplicated genes.'
        },
        {
            id: 'n_clusters',
            name: 'Cluster Count',
            short: 'Clusters',
            color: '#8b5cf6',
            enabled: true,
            desc: 'Number of distinct pangenome clusters this genome contributes to. Each cluster represents a gene family (orthologs/paralogs across genomes). Ideally close to gene count; lower values suggest many duplicated genes.'
        },
        {
            id: 'core_pct',
            name: 'Core %',
            short: 'Core %',
            color: '#22c55e',
            enabled: true,
            desc: 'Percentage of genes in this genome that are "core" (present in >95% of reference genomes). Higher percentages indicate this genome contains mostly essential/conserved functions. Values >100% occur when a genome has multiple copies of core genes.'
        },
        {
            id: 'n_contigs',
            name: 'Assembly Contigs',
            short: 'Contigs',
            color: '#f59e0b',
            enabled: true,
            desc: 'Number of contiguous DNA sequences (contigs) in the genome assembly. Lower is better - fewer contigs indicates a more complete, higher-quality assembly. A value of 1 means a complete chromosome. High values (>100) suggest fragmented or draft-quality assemblies.'
        },
        {
            id: 'missing_core',
            name: 'Missing Core Genes',
            short: 'Missing Core',
            color: '#ef4444',
            enabled: true,
            desc: 'Number of core pangenome clusters that are absent from this genome. Core clusters are those present in >95% of reference genomes. A genome missing many core genes may indicate: (1) assembly gaps/incompleteness, (2) genuine gene loss in this lineage, or (3) highly divergent orthologs not detected by clustering. Zero missing = genome contains all expected core genes.'
        },
        {
            id: 'ko_pct',
            name: 'KEGG Coverage',
            short: 'KEGG %',
            color: '#8b5cf6',
            enabled: false,
            desc: 'Percentage of genes with KEGG Orthology (KO) assignments. KO links genes to metabolic pathways and functional modules. Higher coverage indicates better metabolic annotation. User genome only.'
        },
        {
            id: 'avg_consistency',
            name: 'Avg Consistency',
            short: 'Consistency',
            color: '#f97316',
            enabled: false,
            desc: 'Average annotation consistency score across all genes. Measures how well gene annotations agree with orthologs in the same pangenome cluster. Higher scores (closer to 1.0) indicate more reliable annotations. User genome only.'
        },
        {
            id: 'metabolic_genes',
            name: 'Metabolic Genes',
            short: 'Metabolic',
            color: '#10b981',
            enabled: false,
            desc: 'Number of genes associated with metabolic reactions in the FBA model. Indicates metabolic capability - more genes typically means broader metabolic versatility. User genome only (requires genome-specific metabolic model).'
        },
    ];

    // === TAB SWITCHING ===
    function switchTab(tabId) {
        activeTab = tabId;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tabId));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.toggle('active', t.id === 'tab-' + tabId));

        // Setup section collapse for the active tab (handles newly loaded tabs)
        setupSectionCollapse();

        if (tabId === 'tree') {
            if (!treeLoaded) loadTreeData();
            if (!summaryLoaded) loadSummaryData();
        }
        if (tabId === 'cluster' && !clusterLoaded) loadClusterData();
        if (tabId === 'distributions' && !distributionsLoaded) initDistributions();
        if (tabId === 'metabolic') {
            if (!metabolicLoaded) loadMetabolicData();
            if (!summaryLoaded) loadSummaryData();
        }
        if (tabId === 'tracks') {
            resize();
            render();
            renderMinimap();
            if (!summaryLoaded) loadSummaryData();
        }
    }

    // === CONFIG + DATA LOADING ===
    async function loadConfig() {
        try {
            const resp = await fetch('config.json');
            CONFIG = await resp.json();

            // Load metadata (genome-specific info from database)
            if (CONFIG.data_files && CONFIG.data_files.metadata) {
                try {
                    const metaResp = await fetch(CONFIG.data_files.metadata);
                    METADATA = await metaResp.json();
                    console.log(`Loaded genome: ${METADATA.organism} (${METADATA.n_genes} genes, ${METADATA.n_ref_genomes} refs)`);
                } catch (e) {
                    console.warn('metadata.json not found, using config defaults');
                }
            }

            // Apply config overrides
            if (CONFIG.fields) F = CONFIG.fields;
            if (CONFIG.categories) {
                if (CONFIG.categories.localization) LOC_NAMES = CONFIG.categories.localization;
                if (CONFIG.categories.pangenome) PAN_NAMES = CONFIG.categories.pangenome;
            }

            // Apply track enabled states from config
            if (CONFIG.tracks) {
                const configTrackMap = {};
                CONFIG.tracks.forEach(ct => { configTrackMap[ct.id] = ct; });
                TRACKS.forEach(t => {
                    const ct = configTrackMap[t.id];
                    if (ct) {
                        if (ct.enabled !== undefined) t.enabled = ct.enabled;
                        if (ct.name) t.name = ct.name;
                        if (ct.field !== undefined) t.field = typeof ct.field === 'string' ? F[ct.field] : ct.field;
                    }
                });
            }

            // Update page title
            if (CONFIG.title) document.title = CONFIG.title;

        } catch (e) {
            console.log('No config.json found, using defaults');
            CONFIG = {};
        }
    }

    async function loadData() {
        try {
            await loadConfig();
            const genesFile = (CONFIG.data_files && CONFIG.data_files.genes) || 'genes_data.json';
            const response = await fetch(genesFile);
            genes = await response.json();
            sortedIndices = genes.map((_, i) => i);

            // Load reactions data for metabolic tracks (but not Escher maps yet)
            await loadReactionsData();

            init();
        } catch (e) {
            console.error('Failed to load data:', e);
            document.getElementById('info').textContent = 'Error loading data. Make sure genes_data.json exists.';
        }
    }

    async function init() {
        canvas = document.getElementById('heatmap');
        ctx = canvas.getContext('2d');
        renderKPI();
        renderAnalysisViews();
        renderTrackList();
        renderSortPresets();
        setupEventListeners();
        setupSectionCollapse();
        resize();
        render();
        renderMinimap();
        document.getElementById('info').textContent = `${genes.length} genes loaded`;

        // Load summary data and render in new locations
        await loadSummaryData();
        // renderProteinDistribution(); // REMOVED: Function not defined, not needed
    }

    function setupSectionCollapse() {
        // Remove any existing listeners to avoid duplicates
        document.querySelectorAll('.sidebar-section-title').forEach(title => {
            if (!title._collapseWired) {
                title.addEventListener('click', () => {
                    title.parentElement.classList.toggle('collapsed');
                });
                title._collapseWired = true;
            }
        });
    }

    // === KPI CARDS ===
    function renderKPI() {
        const total = genes.length;
        const core = genes.filter(g => g[F.PAN_CAT] === 2).length;
        const accessory = genes.filter(g => g[F.PAN_CAT] === 1).length;
        const unknown = genes.filter(g => g[F.PAN_CAT] === 0).length;
        const avgCons = genes.filter(g => g[F.AVG_CONS] >= 0);
        const meanCons = avgCons.length ? (avgCons.reduce((s, g) => s + g[F.AVG_CONS], 0) / avgCons.length).toFixed(2) : 'N/A';
        const naCount = genes.filter(g => g[F.AVG_CONS] < 0).length;
        const lowCons = genes.filter(g => g[F.AVG_CONS] >= 0 && g[F.AVG_CONS] < 0.5).length;

        // Missing Core: Count how many core pangenome clusters (>95% conservation) this genome lacks
        // Core clusters are those with conservation_frac > 0.95
        // A cluster is "missing" if no genes in this genome belong to it
        const presentClusters = new Set();
        genes.forEach(g => {
            if (g[F.CLUSTER_SIZE] > 0) {
                // Gene belongs to a cluster - mark it as present
                // Note: We use cluster_size > 0 as proxy for having a cluster
                // Ideally we'd have cluster_id, but we track by conservation_frac
                const cons = g[F.CONS_FRAC];
                if (cons != null && cons > 0.95) {
                    presentClusters.add(Math.floor(cons * 1000)); // Approximate cluster ID
                }
            }
        });
        // Estimate missing core: If we have ~3000 genes and ~2500 clusters,
        // and pangenome has ~4000 clusters, missing core â‰ˆ total_pangenome_core - our_core
        // This is approximate - exact calculation needs full pangenome cluster data
        const estimatedPangenomeCore = Math.floor(total * 1.3); // Rough estimate
        const missingCore = Math.max(0, estimatedPangenomeCore - core);

        document.getElementById('kpi-bar').innerHTML = `
            <span class="kpi-stat" style="font-weight:700; font-style:italic;">${METADATA?.organism || 'Unknown Organism'}</span>
            <span class="kpi-stat"><span class="kpi-label">${METADATA?.genome_id || ''}</span></span>
            <span class="kpi-stat"><span class="kpi-value">${total}</span><span class="kpi-label">genes</span></span>
            <span class="kpi-stat"><span class="kpi-value">${core}</span><span class="kpi-label">core</span></span>
            <span class="kpi-stat"><span class="kpi-value">${accessory}</span><span class="kpi-label">accessory</span></span>
            <span class="kpi-stat"><span class="kpi-value">${unknown}</span><span class="kpi-label">unknown</span></span>
            <span class="kpi-stat" style="background:#c1121f22; border-left:3px solid #c1121f;"><span class="kpi-value" style="color:#c1121f;">${missingCore}</span><span class="kpi-label">missing core</span></span>
            <span class="kpi-stat"><span class="kpi-value">${meanCons}</span><span class="kpi-label">avg consistency</span></span>
            <span class="kpi-stat"><span class="kpi-value">${lowCons}</span><span class="kpi-label">low consistency</span></span>
        `;
    }

    // === ANALYSIS VIEWS ===
    const ANALYSIS_VIEWS = [
        { id: 'characterization', name: 'Characterization Targets',
          tracks: ['pan_category', 'conservation', 'avg_cons', 'specificity'],
          sort: 'pan_status',
          summary: 'Find conserved genes with unknown function',
          desc: '<strong>Characterization Targets</strong>' +
            '<span class="tt-label">Purpose:</span>Identify genes that are conserved across genomes but lack functional annotation. These are high-priority targets for experimental characterization.' +
            '<span class="tt-label">What to look for:</span>Genes that are core (green) with low specificity (blue) and low consistency (blue). These are conserved across genomes but poorly annotated.' +
            '<span class="tt-label">Tracks shown:</span>Core/Accessory + Conservation + Avg Consistency + Specificity' +
            '<span class="tt-label">Example use case:</span>Find core genes (>95% conservation) with low specificity and consistency scores. These are high-value targets because they\'re essential but poorly characterized.' },
        { id: 'annotation_quality', name: 'Annotation Quality',
          tracks: ['avg_cons', 'specificity'],
          sort: 'low_consistency',
          summary: 'Spot annotation conflicts and gaps',
          desc: '<strong>Annotation Quality Assessment</strong>' +
            '<span class="tt-label">Purpose:</span>Evaluate the reliability of functional annotations. Spots genes where consistency is low or specificity is poor.' +
            '<span class="tt-label">What to look for:</span>Genes sorted by lowest consistency first. Blue cells = potential annotation problems. Look for patterns: do certain function types consistently show low consistency?' +
            '<span class="tt-label">Tracks shown:</span>Avg Consistency + Specificity' +
            '<span class="tt-label">Example use case:</span>Genes with low consistency may have unreliable annotations. Prioritize these for manual curation or re-annotation.' },
        { id: 'metabolic', name: 'Metabolic Landscape',
          tracks: ['n_ec', 'n_modules', 'ec_cons', 'ec_map_cons'],
          sort: null,
          summary: 'Map enzymatic and pathway coverage',
          desc: '<strong>Metabolic Landscape</strong>' +
            '<span class="tt-label">Purpose:</span>Visualize which genes have enzymatic activity, participate in metabolic modules, and how consistent their enzyme classifications are.' +
            '<span class="tt-label">What to look for:</span>Dark bands in # EC and Module Hits indicate metabolic gene clusters. Compare EC Consistency vs EC Mapped Consistency to find genes where the EC assignment depends on the mapping method.' +
            '<span class="tt-label">Tracks shown:</span># EC Numbers + KEGG Module Hits + EC Consistency + EC Mapped Consistency' +
            '<span class="tt-label">EC Mapped vs EC Consistency:</span>EC Mapped uses reaction-gene mapping from metabolic model. Regular EC uses direct annotation. Differences reveal model-specific enzyme assignments.' +
            '<span class="tt-label">Example use case:</span>Genes with many EC numbers but low EC consistency may represent multi-functional enzymes or promiscuous annotations. Cross-reference with Metabolic Map tab to visualize on pathways.' },
        { id: 'pangenome', name: 'Pangenome Structure',
          tracks: ['conservation', 'pan_category', 'cluster_size', 'strand'],
          sort: 'conservation',
          summary: 'Explore pangenome architecture and gene families',
          desc: '<strong>Pangenome Structure</strong>' +
            '<span class="tt-label">Purpose:</span>Understand the pangenome architecture: which genes are core vs accessory, how large their gene families are, and where they sit in the genome.' +
            '<span class="tt-label">What to look for:</span>Compare conservation fraction with cluster size. High conservation + small cluster = single-copy essential gene. High conservation + large cluster = expanded gene family with paralogs. Low conservation + small cluster = strain-specific gene.' +
            '<span class="tt-label">Tracks shown:</span>Conservation + Core/Accessory + Cluster Size + Strand' +
            '<span class="tt-label">Cluster Size:</span>Number of genomes in the pangenome containing orthologous genes in this cluster. Larger = more widespread gene family.' +
            '<span class="tt-label">Example use case:</span>Large cluster size + high conservation = ancient gene family present across many genomes. Small cluster + low conservation = recent horizontal gene transfer or lineage-specific innovation.' },
        { id: 'annotation_depth', name: 'Knowledge Coverage',
          tracks: ['has_name', 'n_ko', 'n_go', 'n_pfam', 'n_ec'],
          sort: 'annotation_quality',
          summary: 'How well-characterized is each gene?',
          desc: '<strong>Knowledge Coverage</strong>' +
            '<span class="tt-label">Purpose:</span>See how deeply each gene is characterized across different databases. Well-studied genes have annotations from multiple sources.' +
            '<span class="tt-label">What to look for:</span>Genes with all dark bands are well-characterized across all databases. Genes with all light bands are poorly studied. Mixed patterns (e.g., has KO but no Pfam) reveal database-specific coverage gaps.' +
            '<span class="tt-label">Tracks shown:</span>Has Gene Name + # KO + # GO + # Pfam + # EC' +
            '<span class="tt-label">Annotation Depth sort:</span>Composite score = sum of (N_KO + N_COG + N_PFAM + N_GO + N_EC) + has_name. Higher = more deeply annotated.' +
            '<span class="tt-label">Example use case:</span>Genes with 0 across all sources are completely unknown. Genes with high counts in multiple sources are well-studied with reliable functional predictions.' },
        { id: 'consistency_compare', name: 'Consistency Comparison',
          tracks: ['rast_cons', 'ko_cons', 'bakta_cons', 'ec_cons', 'go_cons'],
          sort: 'low_consistency',
          summary: 'Compare consistency across annotation sources',
          desc: '<strong>Consistency Source Comparison</strong>' +
            '<span class="tt-label">Purpose:</span>Compare how each annotation source (RAST, KO, Bakta, EC, GO) rates gene consistency within pangenome clusters. Sources may disagree on the same gene.' +
            '<span class="tt-label">What to look for:</span>Genes where one source is orange but another is blue. GO consistency tends to be higher (broader terms). EC consistency has more gray (many genes lack EC). RAST and Bakta should loosely agree but use different naming.' +
            '<span class="tt-label">Tracks shown:</span>RAST + KO + Bakta + EC + GO Consistency' +
            '<span class="tt-label">Consistency formula:</span>For each gene, compare its annotation to orthologs in same pangenome cluster. 1.0 (orange) = all agree, 0.0 (blue) = no agreement, N/A (gray) = no cluster or no data.' +
            '<span class="tt-label">Example use case:</span>A gene with high RAST consistency (orange) but low KO consistency (blue) suggests RAST annotation is more stable across orthologs. Use the more consistent source for functional inference.' },
    ];

    let activeView = null;

    let currentSortLabel = null;

    function updateToolbarInfo() {
        const info = document.getElementById('info');
        const parts = [];
        if (activeView) {
            const view = ANALYSIS_VIEWS.find(v => v.id === activeView);
            if (view) parts.push('Showing: ' + view.name);
        }
        if (currentSortLabel) {
            parts.push('Sorted by: ' + currentSortLabel);
        }
        if (parts.length) {
            info.textContent = parts.join('  |  ');
        } else {
            info.textContent = `${genes.length} genes (genome order)`;
        }
    }

    function deactivateAnalysisView() {
        activeView = null;
        TRACKS.forEach(t => { t.enabled = ['order', 'strand', 'conservation', 'pan_category', 'avg_cons'].includes(t.id); });
    }

    function renderAnalysisViews() {
        const container = document.getElementById('analysis-views');
        container.innerHTML = ANALYSIS_VIEWS.map((v, i) =>
            `<button class="analysis-view-btn ${activeView === v.id ? 'active' : ''}" data-view="${v.id}">` +
            `<span><span class="av-name">${v.name}</span><br><span class="av-desc">${v.summary}</span></span>` +
            `<span class="av-info-btn" data-av-desc="${i}">i</span>` +
            `</button>`
        ).join('');

        // Click to activate view
        container.querySelectorAll('.analysis-view-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                if (e.target.classList.contains('av-info-btn')) return;
                const viewId = btn.dataset.view;
                if (activeView === viewId) {
                    deactivateAnalysisView();
                } else {
                    const view = ANALYSIS_VIEWS.find(v => v.id === viewId);
                    activeView = viewId;
                    TRACKS.forEach(t => { t.enabled = view.tracks.includes(t.id); });
                    if (view.sort) applySortPreset(view.sort);
                }
                updateToolbarInfo();
                renderTrackList();
                renderAnalysisViews();
                render();
                renderMinimap();
            });
        });

        // Info tooltips
        const descTooltip = document.getElementById('track-desc-tooltip');
        container.querySelectorAll('.av-info-btn').forEach(btn => {
            btn.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                const view = ANALYSIS_VIEWS[parseInt(e.target.dataset.avDesc)];
                if (!view.desc) return;
                descTooltip.innerHTML = view.desc;
                descTooltip.style.display = 'block';
                const rect = e.target.getBoundingClientRect();
                descTooltip.style.left = (rect.right + 8) + 'px';
                const ttHeight = descTooltip.offsetHeight;
                const maxTop = window.innerHeight - ttHeight - 10;
                descTooltip.style.top = Math.max(10, Math.min(rect.top, maxTop)) + 'px';
            });
            btn.addEventListener('mouseleave', () => { descTooltip.style.display = 'none'; });
        });
    }

    // === TRACK LIST ===
    function renderTrackList() {
        const list = document.getElementById('track-list');
        list.innerHTML = TRACKS.map((track, i) => `
            <div class="track-item ${track.enabled ? 'active' : ''}" data-track="${i}">
                <input type="checkbox" id="track-${i}" ${track.enabled ? 'checked' : ''} onchange="toggleTrack(${i})">
                <span class="info-btn" data-desc="${i}">i</span>
                <label for="track-${i}">${track.name}</label>
                <button class="sort-btn" onclick="sortByTrack(${i}); event.stopPropagation();">Sort &#8595;</button>
            </div>
        `).join('');

        const descTooltip = document.getElementById('track-desc-tooltip');
        list.querySelectorAll('.info-btn').forEach(btn => {
            btn.addEventListener('mouseenter', (e) => {
                const track = TRACKS[parseInt(e.target.dataset.desc)];
                if (!track.desc) return;
                descTooltip.innerHTML = track.desc;
                descTooltip.style.display = 'block';
                const rect = e.target.getBoundingClientRect();
                descTooltip.style.left = (rect.right + 8) + 'px';
                // Smart vertical positioning: don't let tooltip go off-screen
                const ttHeight = descTooltip.offsetHeight;
                const maxTop = window.innerHeight - ttHeight - 10;
                descTooltip.style.top = Math.max(10, Math.min(rect.top, maxTop)) + 'px';
            });
            btn.addEventListener('mouseleave', () => { descTooltip.style.display = 'none'; });
        });
    }

    // === SORT PRESETS ===
    function renderSortPresets() {
        const container = document.getElementById('sort-presets');
        container.innerHTML = SORT_PRESETS.map((p, i) =>
            `<span class="sort-preset-wrapper"><button class="sort-preset-btn ${currentSort === p.id ? 'active' : ''}" onclick="applySortPreset('${p.id}')">${p.name}</button><span class="sort-info-btn" data-sort-desc="${i}">i</span></span>`
        ).join('');

        const descTooltip = document.getElementById('track-desc-tooltip');
        container.querySelectorAll('.sort-info-btn').forEach(btn => {
            btn.addEventListener('mouseenter', (e) => {
                const preset = SORT_PRESETS[parseInt(e.target.dataset.sortDesc)];
                if (!preset.desc) return;
                descTooltip.innerHTML = preset.desc;
                descTooltip.style.display = 'block';
                const rect = e.target.getBoundingClientRect();
                descTooltip.style.left = (rect.right + 8) + 'px';
                const ttHeight = descTooltip.offsetHeight;
                const maxTop = window.innerHeight - ttHeight - 10;
                descTooltip.style.top = Math.max(10, Math.min(rect.top, maxTop)) + 'px';
            });
            btn.addEventListener('mouseleave', () => { descTooltip.style.display = 'none'; });
        });
    }

    function applySortPreset(presetId) {
        const preset = SORT_PRESETS.find(p => p.id === presetId);
        if (!preset) return;
        if (presetId === 'genome') {
            sortedIndices = genes.map((_, i) => i);
        } else {
            sortedIndices = [...Array(genes.length).keys()].sort((a, b) => preset.fn(a, b, genes));
        }
        currentSort = preset.id;
        currentSortLabel = (preset.id === 'genome') ? null : preset.name;
        renderSortPresets();
        updateToolbarInfo();
        render();
        renderMinimap();
    }

    // === SEARCH ===
    function handleSearch(query) {
        const info = document.getElementById('search-info');
        searchMatches.clear();
        if (!query || query.length < 2) {
            info.style.display = 'none';
            info.innerHTML = '';
            render();
            renderMinimap();
            return;
        }
        const q = query.toLowerCase();

        // Enhanced search: ID, function, reactions
        const matches = [];
        genes.forEach((g, i) => {
            const fid = String(g[CONFIG.fields.FID] || '').toLowerCase();
            const func = (g[CONFIG.fields.FUNC] || '').toLowerCase();
            const reactions = (g[CONFIG.fields.REACTIONS] || '').toLowerCase();

            // Check if it's an exact ID match
            const exactMatch = fid === q || fid.startsWith(q);

            // Check other fields
            const funcMatch = func.includes(q);
            const reactionMatch = reactions.includes(q);

            if (exactMatch || funcMatch || reactionMatch) {
                searchMatches.add(i);
                matches.push({
                    idx: i,
                    fid: g[CONFIG.fields.FID],
                    func: g[CONFIG.fields.FUNC] || 'Unknown function',
                    exact: exactMatch,
                    score: exactMatch ? 100 : (funcMatch ? 50 : 25)
                });
            }
        });

        // Sort matches by score (exact matches first)
        matches.sort((a, b) => b.score - a.score);

        // Display search results
        if (matches.length === 0) {
            info.innerHTML = '<div style="color:#E07B39;">No matches found</div>';
            info.style.display = 'block';
        } else if (matches.length === 1) {
            info.innerHTML = `<div>1 match: <strong>${matches[0].fid}</strong></div>`;
            info.style.display = 'block';
        } else if (matches.length <= 5) {
            let html = `<div style="margin-bottom:4px;"><strong>${matches.length} matches:</strong></div>`;
            for (const m of matches) {
                const shortFunc = m.func.length > 40 ? m.func.substring(0, 40) + '...' : m.func;
                html += `<div style="font-size:10px; padding:2px 0; cursor:pointer;" onclick="jumpToGene(${m.idx})">
                    <span style="color:var(--kb-accent); font-weight:600;">${m.fid}</span>
                    <span style="color:var(--kb-base); margin-left:4px;">${shortFunc}</span>
                </div>`;
            }
            info.innerHTML = html;
            info.style.display = 'block';
        } else {
            info.innerHTML = `<div><strong>${matches.length} matches</strong> (showing first 5)</div>`;
            for (let i = 0; i < 5; i++) {
                const m = matches[i];
                const shortFunc = m.func.length > 40 ? m.func.substring(0, 40) + '...' : m.func;
                info.innerHTML += `<div style="font-size:10px; padding:2px 0; cursor:pointer;" onclick="jumpToGene(${m.idx})">
                    <span style="color:var(--kb-accent); font-weight:600;">${m.fid}</span>
                    <span style="color:var(--kb-base); margin-left:4px;">${shortFunc}</span>
                </div>`;
            }
            info.style.display = 'block';
        }

        // Jump to first match
        if (matches.length > 0) {
            const firstMatch = matches[0].idx;
            const posInSorted = sortedIndices.indexOf(firstMatch);
            if (posInSorted >= 0) {
                const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
                scrollPosition = Math.min(1, posInSorted / Math.max(1, genes.length - visibleGenes));
            }
        }
        render();
        renderMinimap();
    }

    function jumpToGene(geneIdx) {
        const posInSorted = sortedIndices.indexOf(geneIdx);
        if (posInSorted >= 0) {
            const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
            scrollPosition = Math.min(1, posInSorted / Math.max(1, genes.length - visibleGenes));
            showGeneDetail(geneIdx);
            render();
            renderMinimap();
        }
    }

    // === GENE DETAIL PANEL ===
    function showGeneDetail(geneIdx) {
        const gene = genes[geneIdx];
        selectedGene = geneIdx;
        const panel = document.getElementById('gene-detail-panel');
        const title = document.getElementById('detail-title');
        const body = document.getElementById('detail-body');

        title.textContent = `Gene ${gene[F.FID]}`;

        const consBar = (val) => {
            if (val < 0) return '<span style="color:#9D9389">N/A</span>';
            const color = COLORS.consistency(val);
            return `<span class="cons-bar" style="background:${color}"></span>${val.toFixed(4)}`;
        };

        body.innerHTML = `
            <div class="detail-section">
                <div class="detail-section-title">Function</div>
                <div class="detail-func">${gene[F.FUNC] || 'No function annotation'}</div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Genomic Location</div>
                <div class="detail-row"><span class="detail-label">Position</span><span class="detail-value">${gene[F.START]}</span></div>
                <div class="detail-row"><span class="detail-label">Length</span><span class="detail-value">${gene[F.LENGTH]} bp</span></div>
                <div class="detail-row"><span class="detail-label">Strand</span><span class="detail-value">${gene[F.STRAND] ? '+' : '-'}</span></div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Pangenome</div>
                <div class="detail-row"><span class="detail-label">Category</span><span class="detail-value">${PAN_NAMES[gene[F.PAN_CAT]]}</span></div>
                <div class="detail-row"><span class="detail-label">Conservation</span><span class="detail-value">${(gene[F.CONS_FRAC] * 100).toFixed(1)}%</span></div>
                <div class="detail-row"><span class="detail-label">Cluster Size</span><span class="detail-value">${gene[F.CLUSTER_SIZE] || 'N/A'}</span></div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Consistency Scores</div>
                <div class="detail-row"><span class="detail-label">Average</span><span class="detail-value">${consBar(gene[F.AVG_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">RAST</span><span class="detail-value">${consBar(gene[F.RAST_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">KO</span><span class="detail-value">${consBar(gene[F.KO_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">GO</span><span class="detail-value">${consBar(gene[F.GO_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">EC</span><span class="detail-value">${consBar(gene[F.EC_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">EC Mapped</span><span class="detail-value">${consBar(gene[F.EC_MAP_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">Bakta</span><span class="detail-value">${consBar(gene[F.BAKTA_CONS])}</span></div>
                <div class="detail-row"><span class="detail-label">Specificity</span><span class="detail-value">${consBar(gene[F.SPECIFICITY])}</span></div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Annotation</div>
                <div class="detail-row"><span class="detail-label">Gene Name</span><span class="detail-value">${gene[F.HAS_NAME] ? 'Yes' : 'No'}</span></div>
                <div class="detail-row"><span class="detail-label">Protein Length</span><span class="detail-value">${gene[F.PROT_LEN]} aa</span></div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Annotation Counts</div>
                <div class="detail-row"><span class="detail-label">KEGG</span><span class="detail-value">${gene[F.N_KO]}</span></div>
                <div class="detail-row"><span class="detail-label">COG</span><span class="detail-value">${gene[F.N_COG]}</span></div>
                <div class="detail-row"><span class="detail-label">Pfam</span><span class="detail-value">${gene[F.N_PFAM]}</span></div>
                <div class="detail-row"><span class="detail-label">GO</span><span class="detail-value">${gene[F.N_GO]}</span></div>
                <div class="detail-row"><span class="detail-label">EC</span><span class="detail-value">${gene[F.N_EC]}</span></div>
                <div class="detail-row"><span class="detail-label">KEGG Modules</span><span class="detail-value">${gene[F.N_MODULES]}</span></div>
            </div>
            <div class="detail-section">
                <div class="detail-section-title">Localization</div>
                <div class="detail-row"><span class="detail-label">PSORTb</span><span class="detail-value">${LOC_NAMES[gene[F.LOC]] || 'Unknown'}</span></div>
            </div>
        `;
        panel.classList.add('open');
    }

    function closeDetail() {
        document.getElementById('gene-detail-panel').classList.remove('open');
        selectedGene = null;
    }

    // === TOGGLE / ACTIONS ===
    function toggleTrack(idx) {
        TRACKS[idx].enabled = !TRACKS[idx].enabled;
        renderTrackList();
        render();
        renderMinimap();
    }
    function selectAll() { TRACKS.forEach(t => t.enabled = true); renderTrackList(); render(); renderMinimap(); }
    function deselectAll() { TRACKS.forEach(t => t.enabled = false); renderTrackList(); render(); renderMinimap(); }

    function exportCurrentView() {
        // Export currently visible/sorted genes to CSV
        const headers = ['Gene_ID', 'Function', 'Start', 'Length', 'Strand', 'Conservation', 'Category', 'Avg_Consistency'];
        const rows = [headers.join(',')];

        for (const idx of sortedIndices) {
            const g = genes[idx];
            const fid = g[CONFIG.fields.FID];
            const func = (g[CONFIG.fields.FUNC] || '').replace(/,/g, ';').replace(/"/g, '""');
            const start = g[CONFIG.fields.START];
            const length = g[CONFIG.fields.LENGTH];
            const strand = g[CONFIG.fields.STRAND] === 1 ? '+' : '-';
            const cons = g[CONFIG.fields.CONS_FRAC];
            const cat = ['Unknown', 'Accessory', 'Core'][g[CONFIG.fields.PAN_CAT]] || 'Unknown';
            const avgCons = g[CONFIG.fields.AVG_CONS];

            rows.push(`${fid},"${func}",${start},${length},${strand},${cons},${cat},${avgCons}`);
        }

        const csv = rows.join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `genome_view_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function exportAllGenes() {
        // Export all genes with all fields to CSV
        const headers = ['Gene_ID', 'Function', 'Start', 'Length', 'Strand', 'Conservation', 'Category', 'Avg_Consistency', 'RAST_Cons', 'KO_Cons', 'GO_Cons', 'EC_Cons', 'Bakta_Cons', 'Specificity', 'Cluster_Size', 'N_KO', 'N_COG', 'N_Pfam', 'N_GO', 'N_EC', 'Localization', 'Is_Hypothetical', 'N_Phenotypes', 'N_Fitness'];
        const rows = [headers.join(',')];

        for (const g of genes) {
            const fid = g[CONFIG.fields.FID];
            const func = (g[CONFIG.fields.FUNC] || '').replace(/,/g, ';').replace(/"/g, '""');
            const start = g[CONFIG.fields.START];
            const length = g[CONFIG.fields.LENGTH];
            const strand = g[CONFIG.fields.STRAND] === 1 ? '+' : '-';
            const cons = g[CONFIG.fields.CONS_FRAC];
            const cat = ['Unknown', 'Accessory', 'Core'][g[CONFIG.fields.PAN_CAT]] || 'Unknown';
            const avgCons = g[CONFIG.fields.AVG_CONS];
            const rastCons = g[CONFIG.fields.RAST_CONS];
            const koCons = g[CONFIG.fields.KO_CONS];
            const goCons = g[CONFIG.fields.GO_CONS];
            const ecCons = g[CONFIG.fields.EC_CONS];
            const baktaCons = g[CONFIG.fields.BAKTA_CONS];
            const spec = g[CONFIG.fields.SPECIFICITY];
            const clusterSize = g[CONFIG.fields.CLUSTER_SIZE];
            const nKo = g[CONFIG.fields.N_KO];
            const nCog = g[CONFIG.fields.N_COG];
            const nPfam = g[CONFIG.fields.N_PFAM];
            const nGo = g[CONFIG.fields.N_GO];
            const nEc = g[CONFIG.fields.N_EC];
            const loc = g[CONFIG.fields.LOC];
            const isHypo = g[CONFIG.fields.IS_HYPO];
            const nPheno = g[CONFIG.fields.N_PHENOTYPES] || 0;
            const nFit = g[CONFIG.fields.N_FITNESS] || 0;

            rows.push(`${fid},"${func}",${start},${length},${strand},${cons},${cat},${avgCons},${rastCons},${koCons},${goCons},${ecCons},${baktaCons},${spec},${clusterSize},${nKo},${nCog},${nPfam},${nGo},${nEc},${loc},${isHypo},${nPheno},${nFit}`);
        }

        const csv = rows.join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `all_genes_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function sortByTrack(idx) {
        const track = TRACKS[idx];
        sortedIndices = [...Array(genes.length).keys()].sort((a, b) => {
            const va = genes[a][track.field], vb = genes[b][track.field];
            if (typeof va === 'string') return va.localeCompare(vb);
            return vb - va;
        });
        currentSort = null;
        currentSortLabel = track.name;
        renderSortPresets();
        updateToolbarInfo();
        render();
        renderMinimap();
    }

    function resetSort() {
        sortedIndices = genes.map((_, i) => i);
        currentSort = 'genome';
        currentSortLabel = null;
        renderSortPresets();
        updateToolbarInfo();
        render();
        renderMinimap();
    }

    function resetZoom() {
        zoomLevel = 1;
        scrollPosition = 0;
        document.getElementById('zoom-slider').value = 1;
        render();
        renderMinimap();
    }

    // === EVENT LISTENERS ===
    function setupEventListeners() {
        window.addEventListener('resize', () => { resize(); render(); renderMinimap(); });
        document.getElementById('zoom-slider').addEventListener('input', (e) => { zoomLevel = parseFloat(e.target.value); render(); renderMinimap(); });
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', () => { document.getElementById('tooltip').style.display = 'none'; });
        canvas.addEventListener('click', handleClick);

        let searchTimeout;
        document.getElementById('gene-search').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => handleSearch(e.target.value.trim()), 200);
        });

        setupMinimap();
    }

    // === MINIMAP NAVIGATION ===
    let minimapCanvas, minimapCtx;
    let minimapDragging = false;
    let minimapDragOffset = 0;

    function setupMinimap() {
        minimapCanvas = document.getElementById('minimap-canvas');
        minimapCtx = minimapCanvas.getContext('2d');
        const viewport = document.getElementById('minimap-viewport');
        const container = document.getElementById('genome-minimap');

        // Drag viewport
        viewport.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            minimapDragging = true;
            viewport.classList.add('dragging');
            const rect = viewport.getBoundingClientRect();
            minimapDragOffset = e.clientX - rect.left;
        });

        document.addEventListener('mousemove', (e) => {
            if (!minimapDragging) return;
            const containerRect = container.getBoundingClientRect();
            const canvasW = minimapCanvas.width / (window.devicePixelRatio || 1);
            const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
            const viewportW = Math.max(6, (visibleGenes / genes.length) * canvasW);
            const maxLeft = canvasW - viewportW;
            const newLeft = Math.max(0, Math.min(maxLeft, e.clientX - containerRect.left - minimapDragOffset));
            scrollPosition = maxLeft > 0 ? newLeft / maxLeft : 0;
            render();
        });

        document.addEventListener('mouseup', () => {
            if (minimapDragging) {
                minimapDragging = false;
                viewport.classList.remove('dragging');
            }
        });

        // Click on minimap background to jump
        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const canvasW = rect.width;
            const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
            const viewportFrac = visibleGenes / genes.length;
            // Center the viewport on the click position
            const targetCenter = clickX / canvasW;
            scrollPosition = Math.max(0, Math.min(1, (targetCenter - viewportFrac / 2) / (1 - viewportFrac)));
            if (genes.length <= visibleGenes) scrollPosition = 0;
            render();
        });

        // Mouse wheel on minimap to scroll
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
            const step = 0.05;
            scrollPosition = Math.max(0, Math.min(1, scrollPosition + (e.deltaY > 0 ? step : -step)));
            render();
        }, { passive: false });
    }

    function renderMinimap() {
        if (!minimapCanvas || !genes.length) return;
        const container = document.getElementById('genome-minimap');
        const dpr = window.devicePixelRatio || 1;
        const displayW = container.clientWidth;
        const displayH = 36;
        minimapCanvas.width = displayW * dpr;
        minimapCanvas.height = displayH * dpr;
        minimapCanvas.style.width = displayW + 'px';
        minimapCanvas.style.height = displayH + 'px';
        minimapCtx.scale(dpr, dpr);

        // Clear
        minimapCtx.fillStyle = '#F2EFEB';
        minimapCtx.fillRect(0, 0, displayW, displayH);

        // Pick the best track to visualize: prefer conservation, then core/accessory, then first enabled
        const enabledTracks = TRACKS.filter(t => t.enabled);
        let primaryTrack = enabledTracks.find(t => t.id === 'conservation') ||
                           enabledTracks.find(t => t.id === 'pan_category') ||
                           enabledTracks.find(t => t.id === 'avg_consistency') ||
                           enabledTracks[0];

        if (!primaryTrack) {
            // No tracks enabled, draw placeholder
            minimapCtx.fillStyle = '#e5e7eb';
            minimapCtx.fillRect(0, 0, displayW, displayH);
            updateMinimapViewport();
            return;
        }

        // Compute stats for sequential tracks
        let trackMin = 0, trackMax = 1, trackRange = 1;
        if (primaryTrack.type === 'sequential') {
            trackMin = Infinity; trackMax = -Infinity;
            for (let i = 0; i < genes.length; i++) {
                const v = genes[i][primaryTrack.field];
                if (v < trackMin) trackMin = v;
                if (v > trackMax) trackMax = v;
            }
            trackRange = trackMax - trackMin || 1;
        }

        // Draw each gene as a colored column
        const n = genes.length;
        const geneW = displayW / n;
        const hasSearch = searchMatches.size > 0;

        for (let i = 0; i < n; i++) {
            const realIdx = sortedIndices[i];
            const gene = genes[realIdx];
            const x = i * geneW;
            const value = gene[primaryTrack.field];

            let color;
            if (primaryTrack.type === 'sequential') {
                color = COLORS.sequential((value - trackMin) / trackRange);
            } else if (primaryTrack.type === 'binary') {
                color = COLORS.binary(value);
            } else if (primaryTrack.type === 'categorical') {
                color = COLORS.categorical(value);
            } else if (primaryTrack.type === 'consistency') {
                color = COLORS.consistency(value);
            } else {
                color = COLORS.placeholder();
            }

            minimapCtx.fillStyle = color;
            minimapCtx.fillRect(x, 0, Math.max(1, Math.ceil(geneW)), displayH);
        }

        // Draw search match highlights
        if (hasSearch) {
            // Dim the whole minimap first
            minimapCtx.fillStyle = 'rgba(255,255,255,0.6)';
            minimapCtx.fillRect(0, 0, displayW, displayH);
            // Highlight matched genes
            minimapCtx.fillStyle = '#ef4444';
            for (const realIdx of searchMatches) {
                const sortedPos = sortedIndices.indexOf(realIdx);
                if (sortedPos >= 0) {
                    const x = sortedPos * geneW;
                    minimapCtx.fillRect(x, 0, Math.max(2, Math.ceil(geneW)), displayH);
                }
            }
        }

        updateMinimapViewport();
    }

    function updateMinimapViewport() {
        const viewport = document.getElementById('minimap-viewport');
        if (!minimapCanvas || !genes.length) return;
        const container = document.getElementById('genome-minimap');
        const canvasW = container.clientWidth;
        const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
        const viewportW = Math.max(6, (visibleGenes / genes.length) * canvasW);
        const maxLeft = canvasW - viewportW;
        const left = scrollPosition * maxLeft;

        viewport.style.width = viewportW + 'px';
        viewport.style.left = left + 'px';

        // Update label
        const label = document.getElementById('minimap-label');
        const enabledTracks = TRACKS.filter(t => t.enabled);
        const primaryTrack = enabledTracks.find(t => t.id === 'conservation') ||
                             enabledTracks.find(t => t.id === 'pan_category') ||
                             enabledTracks.find(t => t.id === 'avg_consistency') ||
                             enabledTracks[0];
        if (label) label.textContent = primaryTrack ? `Overview: ${primaryTrack.name}` : 'Genome overview';
    }

    // === TOOLTIP (enriched) ===
    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const enabledTracks = TRACKS.filter(t => t.enabled);
        const labelWidth = 140;
        const trackHeight = Math.min(40, (canvas.height - 10) / enabledTracks.length);
        const heatmapWidth = canvas.width - labelWidth - 10;
        const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
        const startIdx = Math.floor(scrollPosition * Math.max(0, genes.length - visibleGenes));
        const geneWidth = heatmapWidth / visibleGenes;

        if (x < labelWidth) { document.getElementById('tooltip').style.display = 'none'; return; }

        const geneIdx = Math.floor((x - labelWidth) / geneWidth) + startIdx;
        const trackIdx = Math.floor((y - 5) / trackHeight);

        if (geneIdx >= 0 && geneIdx < genes.length && trackIdx >= 0 && trackIdx < enabledTracks.length) {
            const gene = genes[sortedIndices[geneIdx]];
            const track = enabledTracks[trackIdx];

            let trackValue = '';
            const raw = track.getValue ? track.getValue(gene) : (track.field >= 0 ? gene[track.field] : null);
            if (raw != null) {
                if (track.type === 'consistency') trackValue = raw < 0 ? 'N/A' : raw.toFixed(4);
                else if (track.type === 'sequential' || track.type === 'flux') trackValue = typeof raw === 'number' ? (Number.isInteger(raw) ? raw : raw.toFixed(4)) : raw;
                else if (track.type === 'binary') trackValue = raw ? '+' : '-';
                else if (track.type === 'categorical' && track.categories) trackValue = track.categories[raw] || raw;
                else if (track.type === 'flux_class') trackValue = FLUX_CLASS_LABELS[raw] || raw;
                else trackValue = raw;
            }

            const fmtCons = (v) => v < 0 ? '<span class="tt-label">N/A</span>' : `<span class="tt-val">${v.toFixed(3)}</span>`;

            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="gene-id">Gene ${gene[F.FID]}</div>
                <div class="tt-row"><span class="tt-label">Position</span><span class="tt-val">${gene[F.START]} | ${gene[F.LENGTH]} bp | ${gene[F.STRAND] ? '+' : '-'}</span></div>
                <div class="tt-row"><span class="tt-label">Pangenome</span><span class="tt-val">${PAN_NAMES[gene[F.PAN_CAT]]} (${(gene[F.CONS_FRAC] * 100).toFixed(0)}%)</span></div>
                <div class="tt-row"><span class="tt-label">${track.name}</span><span class="tt-highlight">${trackValue}</span></div>
                <div class="tt-section">
                    <div class="tt-row"><span class="tt-label">Avg / RAST / Bakta</span><span class="tt-val">${fmtCons(gene[F.AVG_CONS])} / ${fmtCons(gene[F.RAST_CONS])} / ${fmtCons(gene[F.BAKTA_CONS])}</span></div>
                    <div class="tt-row"><span class="tt-label">KO / GO / EC</span><span class="tt-val">${fmtCons(gene[F.KO_CONS])} / ${fmtCons(gene[F.GO_CONS])} / ${fmtCons(gene[F.EC_CONS])}</span></div>
                    <div class="tt-row"><span class="tt-label">Terms</span><span class="tt-val">KO:${gene[F.N_KO]} COG:${gene[F.N_COG]} Pfam:${gene[F.N_PFAM]} GO:${gene[F.N_GO]} EC:${gene[F.N_EC]}</span></div>
                    <div class="tt-row"><span class="tt-label">Location</span><span class="tt-val">${LOC_NAMES[gene[F.LOC]] || '?'}</span></div>
                    <div class="tt-row"><span class="tt-label">Status</span><span class="tt-val">${gene[F.HAS_NAME] ? 'Named' : 'Unnamed'} | ${gene[F.PROT_LEN]}aa</span></div>
                </div>
                <div class="func">${gene[F.FUNC] || 'No function annotation'}</div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = Math.min(e.clientX + 12, window.innerWidth - 400) + 'px';
            tooltip.style.top = Math.min(e.clientY + 12, window.innerHeight - 250) + 'px';
        } else {
            document.getElementById('tooltip').style.display = 'none';
        }
    }

    // === CLICK â†’ GENE DETAIL ===
    function handleClick(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const enabledTracks = TRACKS.filter(t => t.enabled);
        const labelWidth = 140;
        const heatmapWidth = canvas.width - labelWidth - 10;
        const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
        const startIdx = Math.floor(scrollPosition * Math.max(0, genes.length - visibleGenes));
        const geneWidth = heatmapWidth / visibleGenes;

        if (x < labelWidth) return;
        const geneIdx = Math.floor((x - labelWidth) / geneWidth) + startIdx;
        if (geneIdx >= 0 && geneIdx < genes.length) {
            showGeneDetail(sortedIndices[geneIdx]);
        }
    }

    // === RESIZE ===
    function resize() {
        const container = document.querySelector('.heatmap-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
    }

    // === RENDER ===
    function render() {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const enabledTracks = TRACKS.filter(t => t.enabled);
        if (enabledTracks.length === 0) {
            ctx.fillStyle = '#9D9389';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Select tracks from the sidebar to display', canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left';
            renderLegend(enabledTracks);
            return;
        }

        const labelWidth = 140;
        const trackHeight = Math.min(40, (canvas.height - 10) / enabledTracks.length);
        const heatmapWidth = canvas.width - labelWidth - 10;
        const visibleGenes = Math.max(100, Math.floor(genes.length / zoomLevel));
        const startIdx = Math.floor(scrollPosition * Math.max(0, genes.length - visibleGenes));
        const endIdx = Math.min(genes.length, startIdx + visibleGenes);
        const geneWidth = heatmapWidth / visibleGenes;

        document.getElementById('position-info').textContent = `${startIdx} - ${endIdx} of ${genes.length}`;

        // Compute min/max for sequential and flux tracks
        const trackStats = {};
        enabledTracks.forEach(track => {
            if (track.type === 'sequential' || track.type === 'flux') {
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < genes.length; i++) {
                    const v = track.getValue ? track.getValue(genes[i]) : genes[i][track.field];
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                trackStats[track.id] = { min, max, range: max - min || 1 };
            }
        });

        const hasSearch = searchMatches.size > 0;

        // Draw tracks
        enabledTracks.forEach((track, ti) => {
            const y = 5 + ti * trackHeight;

            // Track label
            ctx.fillStyle = '#F2EFEB';
            ctx.fillRect(0, y, labelWidth - 5, trackHeight - 2);
            ctx.fillStyle = '#3E3832';
            ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(track.name, 8, y + trackHeight / 2 + 4);

            // Heatmap cells
            for (let i = startIdx; i < endIdx; i++) {
                const realIdx = sortedIndices[i];
                const gene = genes[realIdx];
                const x = labelWidth + (i - startIdx) * geneWidth;
                // Get value from field or getValue function
                const value = track.getValue ? track.getValue(gene) : gene[track.field];

                let color;
                if (track.type === 'sequential') {
                    const stats = trackStats[track.id];
                    color = COLORS.sequential((value - stats.min) / stats.range);
                } else if (track.type === 'binary') {
                    color = COLORS.binary(value);
                } else if (track.type === 'categorical') {
                    color = COLORS.categorical(value);
                } else if (track.type === 'consistency') {
                    color = COLORS.consistency(value);
                } else if (track.type === 'flux') {
                    // Diverging scale for flux: blue (negative) - white (0) - red (positive)
                    const stats = trackStats[track.id];
                    const maxAbs = Math.max(Math.abs(stats.min), Math.abs(stats.max));
                    const normalized = value / (maxAbs || 1);  // -1 to 1
                    // Map to color: -1=blue, 0=white, 1=red
                    if (normalized < 0) {
                        const t = Math.abs(normalized);  // 0 to 1
                        const r = Math.floor(255 - (255 - 37) * t);
                        const g = Math.floor(255 - (255 - 99) * t);
                        const b = 255;
                        color = `rgb(${r}, ${g}, ${b})`;
                    } else {
                        const t = normalized;  // 0 to 1
                        const r = Math.floor(255 + (220 - 255) * t);
                        const g = Math.floor(255 - (255 - 38) * t);
                        const b = Math.floor(255 - (255 - 38) * t);
                        color = `rgb(${r}, ${g}, ${b})`;
                    }
                } else if (track.type === 'flux_class') {
                    // Categorical colors for flux classes
                    color = FLUX_CLASS_COLORS[value] || '#e5e7eb';
                } else {
                    color = COLORS.placeholder();
                }

                ctx.fillStyle = color;
                ctx.fillRect(x, y, Math.max(1, geneWidth - 0.5), trackHeight - 2);

                // Dim non-matching genes during search
                if (hasSearch && !searchMatches.has(realIdx)) {
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillRect(x, y, Math.max(1, geneWidth - 0.5), trackHeight - 2);
                }
            }
        });

        renderLegend(enabledTracks);
        updateMinimapViewport();
    }

    // === LEGEND ===
    // Legend definitions per track type, with tooltip text
    const LEGEND_DEFS = {
        sequential: {
            html: '<span class="legend-label">Gradient:</span><span>Low</span>' +
                '<div class="legend-color" style="background: linear-gradient(to right, rgb(235,240,250), rgb(45,100,180)); width: 50px;"></div>' +
                '<span>High</span>',
            tip: 'Continuous gradient from light (low value) to dark blue (high value). Tracks like Gene Order, Conservation, Cluster Size, and annotation counts use this scale. Values are normalized within each track so the gradient always spans min to max for that track.'
        },
        consistency: {
            html: '<span class="legend-label">Consistency:</span><span>0</span>' +
                '<div class="legend-color" style="background: linear-gradient(to right, #2563eb, #ffffff, #f97316); width: 50px;"></div>' +
                '<span>1</span>' +
                '<div class="legend-color" style="background: #e5e7eb;"></div><span>N/A</span>',
            tip: 'Blue (0) = this gene\'s annotation disagrees with other genes in its pangenome cluster. White (0.5) = partial agreement. Orange (1.0) = full agreement. Gray = no pangenome cluster assigned or no annotation for this source. Colorblind-safe palette.'
        },
        flux: {
            html: '<span class="legend-label">Flux:</span><span>Reverse</span>' +
                '<div class="legend-color" style="background: linear-gradient(to right, #2563eb, #ffffff, #dc2626); width: 60px;"></div>' +
                '<span>Forward</span>',
            tip: 'Metabolic flux direction and magnitude. Blue = reverse flux (consuming product). White = zero/blocked. Red = forward flux (producing product). Higher intensity = higher flux. Data from Flux Balance Analysis.'
        },
        flux_class: {
            html: '<span class="legend-label">Flux Class:</span>' +
                '<div class="legend-color" style="background: #ef4444;"></div><span>Essential</span>' +
                '<div class="legend-color" style="background: #3b82f6;"></div><span>Forward</span>' +
                '<div class="legend-color" style="background: #8b5cf6;"></div><span>Reverse</span>' +
                '<div class="legend-color" style="background: #22c55e;"></div><span>Reversible</span>' +
                '<div class="legend-color" style="background: #d1d5db;"></div><span>Blocked</span>',
            tip: 'Reaction classification from Flux Variability Analysis. Red = essential (required for growth). Blue = forward-only. Purple = reverse-only. Green = reversible. Gray = blocked/inactive.'
        },
        binary: {
            html: '',
            tip: '',
            perTrack: {
                'strand': {
                    html: '<span class="legend-label">Strand:</span>' +
                        '<div class="legend-color" style="background: #6366f1;"></div><span>Forward (+)</span>' +
                        '<div class="legend-color" style="background: #f97316;"></div><span>Reverse (-)</span>',
                    tip: 'Purple = gene on forward strand. Orange = gene on reverse strand. Blocks of the same color often indicate operons (co-transcribed gene groups).'
                },
                'has_name': {
                    html: '<span class="legend-label">Gene Name:</span>' +
                        '<div class="legend-color" style="background: #6366f1;"></div><span>Named</span>' +
                        '<div class="legend-color" style="background: #f97316;"></div><span>Unnamed</span>',
                    tip: 'Purple = gene has an official gene name (e.g., dnaA, lacZ). Orange = identified only by locus tag, less well-studied.'
                }
            }
        },
        categorical: {
            html: '',
            tip: '',
            perTrack: {
                'pan_category': {
                    html: '<span class="legend-label">Pangenome:</span>' +
                        '<div class="legend-color" style="background: #9ca3af;"></div><span>Unknown</span>' +
                        '<div class="legend-color" style="background: #f59e0b;"></div><span>Accessory</span>' +
                        '<div class="legend-color" style="background: #22c55e;"></div><span>Core</span>',
                    tip: 'Gray = no pangenome cluster match. Orange = present in some reference genomes (accessory). Green = conserved across nearly all reference genomes (core).'
                },
                'localization': {
                    html: '<span class="legend-label">Localization:</span>' +
                        '<div class="legend-color" style="background: #9ca3af;"></div><span>Cyto</span>' +
                        '<div class="legend-color" style="background: #f59e0b;"></div><span>Memb</span>' +
                        '<div class="legend-color" style="background: #22c55e;"></div><span>Peri</span>' +
                        '<div class="legend-color" style="background: #3b82f6;"></div><span>Outer</span>' +
                        '<div class="legend-color" style="background: #8b5cf6;"></div><span>Extra</span>',
                    tip: 'PSORTb predicted location: Cytoplasmic, Cytoplasmic Membrane, Periplasmic, Outer Membrane, Extracellular, or Unknown.'
                }
            }
        }
    };

    function renderLegend(enabledTracks) {
        const legend = document.getElementById('legend');
        if (!enabledTracks || enabledTracks.length === 0) { legend.innerHTML = ''; return; }

        const types = new Set(enabledTracks.map(t => t.type));
        const ids = new Set(enabledTracks.map(t => t.id));
        const items = [];

        // Sequential gradient
        if (types.has('sequential')) {
            items.push({ html: LEGEND_DEFS.sequential.html, tip: LEGEND_DEFS.sequential.tip });
        }

        // Consistency
        if (types.has('consistency')) {
            items.push({ html: LEGEND_DEFS.consistency.html, tip: LEGEND_DEFS.consistency.tip });
        }

        // Binary tracks - show per-track legends
        enabledTracks.filter(t => t.type === 'binary').forEach(t => {
            const def = LEGEND_DEFS.binary.perTrack[t.id];
            if (def) items.push({ html: def.html, tip: def.tip });
        });

        // Categorical tracks - show per-track legends
        enabledTracks.filter(t => t.type === 'categorical').forEach(t => {
            const def = LEGEND_DEFS.categorical.perTrack[t.id];
            if (def) items.push({ html: def.html, tip: def.tip });
        });

        legend.innerHTML = items.map((item, i) =>
            `<div class="legend-item" data-legend-tip="${i}">${item.html}</div>`
        ).join('');

        // Add tooltips
        const descTooltip = document.getElementById('track-desc-tooltip');
        legend.querySelectorAll('.legend-item').forEach(el => {
            el.addEventListener('mouseenter', (e) => {
                const idx = parseInt(el.dataset.legendTip);
                if (!items[idx] || !items[idx].tip) return;
                descTooltip.innerHTML = items[idx].tip;
                descTooltip.style.display = 'block';
                const rect = el.getBoundingClientRect();
                descTooltip.style.left = rect.left + 'px';
                descTooltip.style.top = (rect.top - descTooltip.offsetHeight - 8) + 'px';
            });
            el.addEventListener('mouseleave', () => { descTooltip.style.display = 'none'; });
        });
    }

    // ============================================================
    // === TREE VIEW ===
    // ============================================================
    async function loadTreeData() {
        try {
            const treeFile = (CONFIG && CONFIG.data_files && CONFIG.data_files.tree) || 'tree_data.json';
            const resp = await fetch(treeFile);
            treeData = await resp.json();

            // Load reference genome stats
            if (CONFIG && CONFIG.data_files && CONFIG.data_files.ref_genomes) {
                try {
                    const refGenomesResp = await fetch(CONFIG.data_files.ref_genomes);
                    const refGenomesData = await refGenomesResp.json();

                    // Merge ref genome stats into tree_data
                    Object.entries(refGenomesData.genomes).forEach(([genomeId, stats]) => {
                        if (!treeData.genome_metadata[genomeId]) {
                            treeData.genome_metadata[genomeId] = {};
                        }
                        if (!treeData.genome_metadata[genomeId].stats) {
                            treeData.genome_metadata[genomeId].stats = {};
                        }
                        // Merge stats
                        Object.assign(treeData.genome_metadata[genomeId].stats, stats);
                    });

                    console.log(`Loaded stats for ${Object.keys(refGenomesData.genomes).length} reference genomes`);
                } catch (e) {
                    console.warn('ref_genomes_data.json not available:', e);
                }
            }

            treeLoaded = true;

            // Load cluster data if needed for missing_core computation
            if (!clusterData) {
                try {
                    const clusterFile = (CONFIG && CONFIG.data_files && CONFIG.data_files.cluster) || 'cluster_data.json';
                    const clusterResp = await fetch(clusterFile);
                    clusterData = await clusterResp.json();
                } catch (e) {
                    console.warn('cluster_data.json not available for missing_core computation');
                }
            }

            // NOTE: missing_core stat is now loaded from ref_genomes_data.json (computed by extract_pan_genome_features.py)
            // The previous computeMissingCoreStats() function was incorrect - it counted discrepancies in genes that EXIST,
            // but missing_core should count core clusters the genome LACKS (requires pangenome cluster data).
            // The Python script correctly computes: total_core_clusters - core_genes_in_this_genome

            renderTreeSidebar();
            renderTree();
        } catch (e) {
            console.error('Failed to load tree data:', e);
            document.getElementById('tree-info').textContent = 'Error loading tree_data.json';
        }
    }

    // DEPRECATED: computeMissingCoreStats() - this function was removed because it computed an incorrect value
    // Missing core genes cannot be computed from the genes that EXIST in the user genome.
    // The correct computation requires: total_core_clusters_in_pangenome - core_genes_in_this_genome
    // This is now computed in extract_pan_genome_features.py and loaded from ref_genomes_data.json
    /*
    function computeMissingCoreStats() {
        // INCORRECT LOGIC: This counted genes with CONS_FRAC > 0.95 but PAN_CAT != 2
        // That's a discrepancy/inconsistency, NOT missing genes
        // Missing genes are clusters the genome LACKS entirely
    }
    */

    function renderTreeSidebar() {
        const toggles = document.getElementById('tree-stat-toggles');
        toggles.innerHTML = TREE_STATS.map((s, i) =>
            `<label class="stat-toggle"><input type="checkbox" ${s.enabled ? 'checked' : ''} onchange="toggleTreeStat(${i})"> <span style="color:${s.color}; font-weight:600;">${s.name}</span></label>`
        ).join('');

        const info = document.getElementById('tree-info');
        const d = treeData;
        const userStats = d.genome_stats[d.user_genome_id] || {};
        info.innerHTML = `
            <div><strong>${d.stats.n_genomes}</strong> genomes (${d.stats.n_reference} reference + user)</div>
            <div><strong>${d.stats.n_clusters}</strong> pangenome clusters used</div>
            <div style="margin-top:6px;">Jaccard distance range: <strong>${d.stats.min_distance.toFixed(4)}</strong> - <strong>${d.stats.max_distance.toFixed(4)}</strong></div>
            <div style="margin-top:8px; padding-top:6px; border-top:1px solid #DED5CB; color:#D2232A; font-weight:600;">Your genome: ${d.user_genome_id}</div>
            <div style="color:#6A6158;">${userStats.n_genes || '?'} genes, ${userStats.n_clusters || '?'} clusters, ${userStats.core_pct ? (userStats.core_pct*100).toFixed(1)+'% core' : '?'}</div>
            <div style="margin-top:8px; padding-top:6px; border-top:1px solid #DED5CB; font-size:10px; color:#9D9389; line-height:1.5;">
                <strong style="color:#6A6158;">How to read:</strong> UPGMA tree based on Jaccard distance of pangenome cluster presence/absence. Genomes sharing more clusters are closer. Branch length = distance at which two groups merge. Hover leaf labels for genome details.
            </div>
        `;
    }

    function toggleTreeStat(idx) {
        TREE_STATS[idx].enabled = !TREE_STATS[idx].enabled;
        renderTree();
    }

    function renderTree() {
        if (!treeData) return;
        const container = document.getElementById('tree-container');
        const d = treeData;
        const leafOrder = d.leaf_order;
        const n = leafOrder.length;
        const linkage = d.linkage;

        // Layout params
        const leafH = 24;
        const marginTop = 20;
        const marginBottom = 40;
        const labelWidth = 200;
        const treeWidth = 400;
        const enabledStats = TREE_STATS.filter(s => s.enabled);
        const statBarWidth = enabledStats.length > 0 ? 60 * enabledStats.length : 0;
        const statGap = 16;
        const totalW = labelWidth + treeWidth + statGap + statBarWidth + 40;
        const totalH = marginTop + n * leafH + marginBottom;

        // Build node positions from linkage
        // Leaves: indices 0..n-1, internal nodes: n..2n-2
        const nodeY = new Array(2 * n - 1);
        const nodeX = new Array(2 * n - 1);
        const nodeDepth = new Array(2 * n - 1).fill(0);

        // Assign leaf Y positions based on leaf_order
        const leafIdx = {};
        d.genome_ids.forEach((gid, i) => { leafIdx[gid] = i; });
        leafOrder.forEach((gid, pos) => {
            const li = leafIdx[gid];
            nodeY[li] = marginTop + pos * leafH + leafH / 2;
            nodeX[li] = 0;
        });

        // Max distance for X scaling - use sqrt scale to spread out compressed small distances
        const maxDist = linkage.reduce((m, r) => Math.max(m, r[2]), 0);
        const xScale = (dist) => treeWidth * Math.sqrt(dist / maxDist);

        // Internal nodes - compute positions and track depth
        for (let i = 0; i < linkage.length; i++) {
            const [a, b, dist] = linkage[i];
            const ni = n + i;
            nodeY[ni] = (nodeY[a] + nodeY[b]) / 2;
            nodeX[ni] = xScale(dist);
            nodeDepth[ni] = Math.max(nodeDepth[a], nodeDepth[b]) + 1;
        }

        // Build subtree leaf ranges for coloring clades
        const subtreeMin = new Array(2 * n - 1);
        const subtreeMax = new Array(2 * n - 1);
        // For leaves, min = max = their position in leaf order
        const leafPosMap = {};
        leafOrder.forEach((gid, pos) => { leafPosMap[leafIdx[gid]] = pos; });
        for (let i = 0; i < n; i++) {
            subtreeMin[i] = leafPosMap[i] !== undefined ? leafPosMap[i] : 0;
            subtreeMax[i] = subtreeMin[i];
        }
        for (let i = 0; i < linkage.length; i++) {
            const [a, b] = linkage[i];
            const ni = n + i;
            subtreeMin[ni] = Math.min(subtreeMin[a], subtreeMin[b]);
            subtreeMax[ni] = Math.max(subtreeMax[a], subtreeMax[b]);
        }

        // SVG
        let svg = `<svg width="${totalW}" height="${totalH}" xmlns="http://www.w3.org/2000/svg" style="font-family: -apple-system, BlinkMacSystemFont, sans-serif;">`;

        // Distance reference lines (drawn first, behind branches)
        const scaleY = totalH - 15;
        const scaleDists = [0.05, 0.1, 0.2, 0.3, 0.5];
        scaleDists.forEach(dv => {
            if (dv <= maxDist) {
                const sx = labelWidth + xScale(dv);
                svg += `<line x1="${sx}" y1="${marginTop - 5}" x2="${sx}" y2="${scaleY}" stroke="#f1f5f9" stroke-width="1" stroke-dasharray="4,4"/>`;
                svg += `<text x="${sx}" y="${scaleY + 12}" text-anchor="middle" font-size="9" fill="#9D9389">J=${dv}</text>`;
            }
        });

        // Draw branches (elbow style) with depth-based styling
        // Deeper (closer to leaves) = more opaque; shallower (closer to root) = lighter
        const maxDepth = Math.max(...nodeDepth);
        for (let i = 0; i < linkage.length; i++) {
            const [a, b, dist] = linkage[i];
            const ni = n + i;
            const px = labelWidth + nodeX[ni];
            const ay = nodeY[a], by = nodeY[b];
            const ax = labelWidth + nodeX[a], bx = labelWidth + nodeX[b];
            // Depth-based opacity: deeper merges (near leaves) darker, root merges lighter
            const depth = nodeDepth[ni];
            const opacity = 0.4 + 0.5 * (depth / Math.max(maxDepth, 1));
            const strokeW = depth <= 2 ? 1.0 : 1.5;
            const color = '#64748b';

            // Horizontal line from child A to parent x
            svg += `<line x1="${ax}" y1="${ay}" x2="${px}" y2="${ay}" stroke="${color}" stroke-width="${strokeW}" opacity="${opacity.toFixed(2)}"/>`;
            // Horizontal line from child B to parent x
            svg += `<line x1="${bx}" y1="${by}" x2="${px}" y2="${by}" stroke="${color}" stroke-width="${strokeW}" opacity="${opacity.toFixed(2)}"/>`;
            // Vertical line connecting children at parent's x
            svg += `<line x1="${px}" y1="${ay}" x2="${px}" y2="${by}" stroke="${color}" stroke-width="${strokeW}" opacity="${opacity.toFixed(2)}"/>`;

            // Small node dot at merge point for clarity
            if (depth >= 3) {
                svg += `<circle cx="${px}" cy="${nodeY[ni]}" r="1.5" fill="${color}" opacity="${(opacity * 0.6).toFixed(2)}"/>`;
            }
        }

        // Stat bar scaling - check both genome_stats (legacy) and genome_metadata.stats (new)
        const statMaxes = {};
        enabledStats.forEach(s => {
            let mx = 0;
            // Check genome_metadata.stats first (new structure)
            Object.entries(d.genome_metadata || {}).forEach(([gid, meta]) => {
                if (meta.stats && meta.stats[s.id] != null) {
                    if (meta.stats[s.id] > mx) mx = meta.stats[s.id];
                } else if (meta[s.id] != null) {
                    // Fallback to direct metadata fields (n_contigs, etc.)
                    if (meta[s.id] > mx) mx = meta[s.id];
                }
            });
            // Also check genome_stats (legacy location)
            if (d.genome_stats) {
                Object.values(d.genome_stats).forEach(gs => {
                    if (gs[s.id] != null && gs[s.id] > mx) mx = gs[s.id];
                });
            }
            statMaxes[s.id] = mx || 1;
        });

        // Draw leaves
        leafOrder.forEach((gid, pos) => {
            const y = marginTop + pos * leafH + leafH / 2;
            const isUser = gid === d.user_genome_id;
            const meta = d.genome_metadata[gid] || {};
            const stats = d.genome_stats[gid] || {};
            const tax = meta.tax || {};
            const shortId = gid.replace('RS_GCF_', 'GCF_').replace(/\.1$/, '');
            const displayName = tax.species || shortId;
            // Truncate user genome label to fit better
            let label = isUser ? `${displayName} (YOUR GENOME)` : displayName;
            if (isUser && label.length > 35) {
                label = label.substring(0, 32) + '...';
            }
            const textColor = isUser ? '#dc2626' : '#374151';
            const fontWeight = isUser ? '700' : '400';
            const fontSize = isUser ? '12' : '11';

            // Leaf dot
            svg += `<circle cx="${labelWidth}" cy="${y}" r="${isUser ? 4 : 3}" fill="${isUser ? '#dc2626' : '#64748b'}"/>`;

            // Highlight band for user genome
            if (isUser) {
                svg += `<rect x="0" y="${y - leafH/2}" width="${totalW}" height="${leafH}" fill="#DFEEF6" opacity="0.5"/>`;
            }

            // Label (right-aligned to labelWidth)
            const labelX = labelWidth - 8;
            svg += `<g class="tree-leaf ${isUser ? 'user-genome' : ''}" data-gid="${gid}" style="cursor:pointer;">`;
            // Invisible hit area for hover
            svg += `<rect x="0" y="${y - leafH/2}" width="${labelWidth}" height="${leafH}" fill="transparent"/>`;
            svg += `<text x="${labelX}" y="${y + 4}" text-anchor="end" font-size="${fontSize}" fill="${textColor}" font-weight="${fontWeight}">${label}</text>`;
            svg += `</g>`;

            // Stat bars
            if (enabledStats.length > 0) {
                const barStart = labelWidth + treeWidth + statGap;
                const barW = statBarWidth / enabledStats.length;
                enabledStats.forEach((s, si) => {
                    let val = null;
                    // Check meta.stats first (new structure), then meta directly, then genome_stats (legacy)
                    if (meta.stats && meta.stats[s.id] != null) {
                        val = meta.stats[s.id];
                    } else if (meta[s.id] != null) {
                        val = meta[s.id];
                    } else if (stats[s.id] != null) {
                        val = stats[s.id];
                    }

                    const bx = barStart + si * barW;
                    // Background track
                    svg += `<rect x="${bx}" y="${y - 6}" width="${barW - 6}" height="12" fill="#F2EFEB" rx="1"/>`;

                    if (val === null) {
                        // Show "-" for missing data
                        svg += `<text x="${bx + (barW - 6)/2}" y="${y + 4}" text-anchor="middle" font-size="10" fill="#9D9389">-</text>`;
                    } else {
                        // Value bar (only draw if value > 0)
                        const w = (val / statMaxes[s.id]) * (barW - 6);
                        if (w > 0) {
                            svg += `<rect x="${bx}" y="${y - 6}" width="${w}" height="12" fill="${s.color}" opacity="0.7" rx="1"/>`;
                        }
                    }
                });
            }
        });

        // Stat bar headers with clickable info icons
        if (enabledStats.length > 0) {
            const barStart = labelWidth + treeWidth + statGap;
            const barW = statBarWidth / enabledStats.length;
            enabledStats.forEach((s, si) => {
                const bx = barStart + si * barW;
                svg += `<g class="stat-header" data-stat-id="${s.id}">`;
                svg += `<text x="${bx + (barW - 6)/2}" y="12" text-anchor="middle" font-size="9" fill="${s.color}" font-weight="600">${s.short || s.name}</text>`;
                // Info icon
                if (s.desc) {
                    svg += `<circle cx="${bx + (barW - 6)/2 + 25}" cy="9" r="5" fill="${s.color}" opacity="0.2" class="stat-info-icon"/>`;
                    svg += `<text x="${bx + (barW - 6)/2 + 25}" y="12" text-anchor="middle" font-size="8" fill="${s.color}" font-weight="700" style="cursor:help;">i</text>`;
                }
                svg += `</g>`;
            });
        }

        // Scale axis label
        svg += `<text x="${labelWidth + treeWidth/2}" y="${totalH - 2}" text-anchor="middle" font-size="9" fill="#9D9389">Jaccard distance (sqrt scale)</text>`;

        svg += '</svg>';
        container.innerHTML = svg;

        // Tooltips on leaf hover
        const tooltip = document.getElementById('tree-tooltip');
        container.querySelectorAll('.tree-leaf').forEach(leaf => {
            leaf.addEventListener('mouseenter', (e) => {
                const gid = leaf.dataset.gid;
                const meta = treeData.genome_metadata[gid] || {};
                const stats = treeData.genome_stats[gid] || {};
                const tax = meta.tax || {};
                const ani = meta.ani_to_user != null ? meta.ani_to_user + '%' : 'N/A';
                const pheno = meta.phenotype;
                let phenoHtml = '';
                if (pheno) {
                    phenoHtml = `<div style="margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);"><span style="color:#9D9389;">Phenotype predictions:</span> <span style="color:#f97316;">${pheno.positive_growth} positive</span>, <span style="color:#2563eb;">${pheno.negative_growth} negative</span></div>`;
                }
                tooltip.innerHTML = `
                    <div style="font-weight:700; color:#66B1DB; margin-bottom:4px;">${gid}</div>
                    <div>${tax.species || 'Unknown species'}</div>
                    <div style="color:#9D9389; font-size:10px;">${[tax.phylum, tax.class, tax.order, tax.family, tax.genus].filter(Boolean).join(' > ')}</div>
                    <div style="margin-top:6px;"><span style="color:#9D9389;">Features:</span> ${meta.n_features || '?'} | <span style="color:#9D9389;">Contigs:</span> ${meta.n_contigs || '?'}</div>
                    <div><span style="color:#9D9389;">Genes:</span> ${stats.n_genes || '?'} | <span style="color:#9D9389;">Clusters:</span> ${stats.n_clusters || '?'} | <span style="color:#9D9389;">Core:</span> ${stats.core_pct != null ? (stats.core_pct * 100).toFixed(1) + '%' : '?'}</div>
                    <div><span style="color:#9D9389;">ANI to user:</span> ${ani}</div>
                    ${phenoHtml}
                `;
                tooltip.style.display = 'block';
                const rect = leaf.getBoundingClientRect();
                tooltip.style.left = (rect.right + 10) + 'px';
                tooltip.style.top = Math.max(10, rect.top - 30) + 'px';
            });
            leaf.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
        });

        // Tooltips on stat header hover
        container.querySelectorAll('.stat-header').forEach(header => {
            header.addEventListener('mouseenter', (e) => {
                const statId = header.dataset.statId;
                const stat = TREE_STATS.find(s => s.id === statId);
                if (stat && stat.desc) {
                    tooltip.innerHTML = `
                        <div style="font-weight:700; color:#66B1DB; margin-bottom:6px;">${stat.name}</div>
                        <div style="font-size:11px; line-height:1.5;">${stat.desc}</div>
                    `;
                    tooltip.style.display = 'block';
                    const rect = header.getBoundingClientRect();
                    tooltip.style.left = (rect.left + 10) + 'px';
                    tooltip.style.top = (rect.bottom + 5) + 'px';
                }
            });
            header.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
        });
    }

    // ============================================================
    // === CLUSTER VIEW ===
    // ============================================================
    async function loadClusterData() {
        try {
            const clusterFile = (CONFIG && CONFIG.data_files && CONFIG.data_files.cluster) || 'cluster_data.json';
            const resp = await fetch(clusterFile);
            clusterData = await resp.json();
            clusterLoaded = true;
            clusterCanvas = document.getElementById('cluster-canvas');
            clusterCtx = clusterCanvas.getContext('2d');
            resizeCluster();
            renderCluster();
            setupClusterEvents();
            const core = genes.filter(g => g[F.PAN_CAT] === 2).length;
            const acc = genes.filter(g => g[F.PAN_CAT] === 1).length;
            const unk = genes.filter(g => g[F.PAN_CAT] === 0).length;
            document.getElementById('cluster-info').innerHTML = `
                <div><strong>${genes.length.toLocaleString()}</strong> genes plotted</div>
                <div style="font-size:10px; color:#9D9389; margin-top:2px;">${core} core, ${acc} accessory, ${unk} unknown</div>
                <div style="margin-top:8px; font-size:10px; color:#9D9389; line-height:1.5;">
                    <strong style="color:#6A6158;">How to read:</strong> Each dot is one gene. Genes that are close together have similar properties. Change <em>Embedding</em> to explore different similarity measures. Change <em>Color By</em> to highlight patterns. Hover for gene info, click for full details.
                </div>
                <div style="margin-top:6px; font-size:10px; color:#9D9389; line-height:1.5;">
                    <strong style="color:#6A6158;">Gene Features:</strong> UMAP of 23 gene properties (conservation, consistency scores, annotation counts, protein length). Groups genes with similar functional profiles.
                </div>
                <div style="margin-top:4px; font-size:10px; color:#9D9389; line-height:1.5;">
                    <strong style="color:#6A6158;">Presence/Absence:</strong> UMAP of binary cluster membership across ${METADATA.n_ref_genomes} reference genomes. Groups genes with similar phylogenetic distribution.
                </div>
            `;
        } catch (e) {
            console.error('Failed to load cluster data:', e);
            document.getElementById('cluster-info').textContent = 'Error loading cluster_data.json';
        }
    }

    function resizeCluster() {
        if (!clusterCanvas) return;
        const container = clusterCanvas.parentElement;
        clusterCanvas.width = container.clientWidth;
        clusterCanvas.height = container.clientHeight;
    }

    function changeClusterEmbedding() {
        clusterEmbedding = document.getElementById('cluster-embedding').value;
        const descEl = document.getElementById('cluster-embed-desc');
        if (clusterEmbedding === 'features') {
            descEl.textContent = 'UMAP of conservation, consistency scores, annotation counts, protein length';
        } else {
            const nRef = METADATA.n_ref_genomes;
            descEl.textContent = `UMAP of pangenome cluster presence/absence across ${nRef} reference genomes`;
        }
        clusterZoom = 1; clusterPanX = 0; clusterPanY = 0;
        renderCluster();
    }

    function changeClusterColor() {
        clusterColorBy = document.getElementById('cluster-color-by').value;
        renderCluster();
    }

    function getClusterColor(gene, colorBy) {
        switch (colorBy) {
            case 'pan_category': return COLORS.categorical(gene[F.PAN_CAT]);
            case 'conservation': return COLORS.sequential(gene[F.CONS_FRAC]);
            case 'avg_cons': return COLORS.consistency(gene[F.AVG_CONS]);
            case 'localization': return COLORS.categorical(gene[F.LOC]);
            case 'n_ko': return COLORS.sequential(Math.min(gene[F.N_KO] / 4, 1));
            case 'n_modules': return COLORS.sequential(Math.min(gene[F.N_MODULES] / 5, 1));
            case 'cluster_size': return COLORS.sequential(Math.min(gene[F.CLUSTER_SIZE] / 200, 1));
            case 'specificity': return COLORS.consistency(gene[F.SPECIFICITY]);
            default: return '#6366f1';
        }
    }

    function getClusterTransform() {
        const emb = clusterData[clusterEmbedding];
        if (!emb) return null;
        const xs = emb.x, ys = emb.y;
        const w = clusterCanvas.width, h = clusterCanvas.height;
        let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
        for (let i = 0; i < xs.length; i++) {
            if (xs[i] < xMin) xMin = xs[i]; if (xs[i] > xMax) xMax = xs[i];
            if (ys[i] < yMin) yMin = ys[i]; if (ys[i] > yMax) yMax = ys[i];
        }
        const pad = 40;
        const xRange = xMax - xMin || 1, yRange = yMax - yMin || 1;
        const baseScale = Math.min((w - 2 * pad) / xRange, (h - 2 * pad) / yRange);
        const baseOffX = (w - xRange * baseScale) / 2;
        const baseOffY = (h - yRange * baseScale) / 2;
        return {
            xs, ys, w, h, xMin, yMin, baseScale, baseOffX, baseOffY,
            toScreenX: (v) => (baseOffX + (v - xMin) * baseScale) * clusterZoom + clusterPanX,
            toScreenY: (v) => (baseOffY + (v - yMin) * baseScale) * clusterZoom + clusterPanY,
        };
    }

    function resetClusterZoom() {
        clusterZoom = 1; clusterPanX = 0; clusterPanY = 0;
        renderCluster();
    }

    function updateClusterZoomUI() {
        const btn = document.getElementById('cluster-reset-zoom');
        const info = document.getElementById('cluster-zoom-info');
        if (clusterZoom > 1.05) {
            btn.style.display = '';
            info.textContent = `${clusterZoom.toFixed(1)}x zoom`;
        } else {
            btn.style.display = 'none';
            info.textContent = '';
        }
    }

    function renderCluster() {
        if (!clusterData || !clusterCtx || !genes.length) return;
        const t = getClusterTransform();
        if (!t) return;
        const ctx2 = clusterCtx;
        ctx2.fillStyle = '#ffffff';
        ctx2.fillRect(0, 0, t.w, t.h);

        const { xs, ys, toScreenX, toScreenY } = t;
        const n = xs.length;
        const hasSearch = clusterSearchMatches.size > 0;
        const baseDotR = Math.max(2, Math.min(4, t.w / 400));
        const dotR = Math.min(baseDotR * Math.sqrt(clusterZoom), 20);

        for (let i = 0; i < n; i++) {
            const sx = toScreenX(xs[i]);
            const sy = toScreenY(ys[i]);
            if (sx < -dotR || sx > t.w + dotR || sy < -dotR || sy > t.h + dotR) continue;
            const gene = genes[i];
            const color = getClusterColor(gene, clusterColorBy);
            ctx2.beginPath();
            ctx2.arc(sx, sy, dotR, 0, Math.PI * 2);
            ctx2.fillStyle = color;
            if (hasSearch && !clusterSearchMatches.has(i)) {
                ctx2.globalAlpha = 0.1;
            }
            ctx2.fill();
            ctx2.globalAlpha = 1.0;
        }

        if (hasSearch) {
            for (const i of clusterSearchMatches) {
                const sx = toScreenX(xs[i]);
                const sy = toScreenY(ys[i]);
                if (sx < -10 || sx > t.w + 10 || sy < -10 || sy > t.h + 10) continue;
                ctx2.beginPath();
                ctx2.arc(sx, sy, dotR + 2, 0, Math.PI * 2);
                ctx2.strokeStyle = '#f59e0b';
                ctx2.lineWidth = 2;
                ctx2.stroke();
            }
        }

        updateClusterZoomUI();
        renderClusterLegend();
    }

    function renderClusterLegend() {
        const legend = document.getElementById('cluster-legend');
        let html = '';
        switch (clusterColorBy) {
            case 'pan_category':
                html = '<div class="legend-item"><div class="legend-color" style="background:#9ca3af"></div>Unknown</div>' +
                    '<div class="legend-item"><div class="legend-color" style="background:#f59e0b"></div>Accessory</div>' +
                    '<div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Core</div>';
                break;
            case 'conservation':
            case 'n_ko': case 'n_modules': case 'cluster_size':
                html = '<div class="legend-item"><span>Low</span><div class="legend-color" style="background: linear-gradient(to right, rgb(235,240,250), rgb(45,100,180)); width: 50px;"></div><span>High</span></div>';
                break;
            case 'avg_cons': case 'specificity':
                html = '<div class="legend-item"><span>0</span><div class="legend-color" style="background: linear-gradient(to right, #ef4444, #fbbf24, #22c55e); width: 50px;"></div><span>1</span><div class="legend-color" style="background: #e5e7eb;"></div>N/A</div>';
                break;
            case 'localization':
                html = LOC_NAMES.map((name, i) => `<div class="legend-item"><div class="legend-color" style="background:${COLORS.categorical(i)}"></div>${name}</div>`).join('');
                break;
        }
        legend.innerHTML = html;
    }

    function findNearestClusterGene(mx, my) {
        const t = getClusterTransform();
        if (!t) return -1;
        let bestDist = 100, bestIdx = -1;
        for (let i = 0; i < t.xs.length; i++) {
            const sx = t.toScreenX(t.xs[i]);
            const sy = t.toScreenY(t.ys[i]);
            const d = Math.hypot(sx - mx, sy - my);
            if (d < bestDist) { bestDist = d; bestIdx = i; }
        }
        return bestDist < 15 ? bestIdx : -1;
    }

    function setupClusterEvents() {
        if (!clusterCanvas) return;
        const tooltip = document.getElementById('cluster-tooltip');

        // Hover tooltip
        clusterCanvas.addEventListener('mousemove', (e) => {
            if (!clusterData || !genes.length || clusterDragging) return;
            const rect = clusterCanvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            const idx = findNearestClusterGene(mx, my);
            if (idx >= 0) {
                const gene = genes[idx];
                tooltip.innerHTML = `
                    <div class="gene-id">Gene ${gene[F.FID]}</div>
                    <div class="tt-row"><span class="tt-label">Position</span><span class="tt-val">${gene[F.START]} | ${gene[F.STRAND] ? '+' : '-'}</span></div>
                    <div class="tt-row"><span class="tt-label">Pangenome</span><span class="tt-val">${PAN_NAMES[gene[F.PAN_CAT]]} (${(gene[F.CONS_FRAC] * 100).toFixed(0)}%)</span></div>
                    <div class="tt-row"><span class="tt-label">Avg Consistency</span><span class="tt-val">${gene[F.AVG_CONS] < 0 ? 'N/A' : gene[F.AVG_CONS].toFixed(3)}</span></div>
                    <div class="func">${gene[F.FUNC] || 'No function annotation'}</div>
                `;
                tooltip.style.display = 'block';
                tooltip.style.left = Math.min(e.clientX + 12, window.innerWidth - 380) + 'px';
                tooltip.style.top = Math.min(e.clientY + 12, window.innerHeight - 180) + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        });

        clusterCanvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

        // Click for gene detail
        clusterCanvas.addEventListener('click', (e) => {
            if (!clusterData || !genes.length) return;
            const rect = clusterCanvas.getBoundingClientRect();
            const idx = findNearestClusterGene(e.clientX - rect.left, e.clientY - rect.top);
            if (idx >= 0) showGeneDetail(idx);
        });

        // Wheel zoom (centered on mouse)
        clusterCanvas.addEventListener('wheel', (e) => {
            if (!clusterData) return;
            e.preventDefault();
            const rect = clusterCanvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            const oldZoom = clusterZoom;
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            clusterZoom = Math.max(1, Math.min(50, clusterZoom * factor));
            // Keep the point under the mouse fixed
            clusterPanX = mx - (mx - clusterPanX) * (clusterZoom / oldZoom);
            clusterPanY = my - (my - clusterPanY) * (clusterZoom / oldZoom);
            // Clamp pan when zoomed out to 1x
            if (clusterZoom <= 1) { clusterPanX = 0; clusterPanY = 0; }
            renderCluster();
        }, { passive: false });

        // Drag to pan
        clusterCanvas.addEventListener('mousedown', (e) => {
            if (!clusterData || clusterZoom <= 1) return;
            clusterDragging = true;
            clusterDragStartX = e.clientX;
            clusterDragStartY = e.clientY;
            clusterDragPanX = clusterPanX;
            clusterDragPanY = clusterPanY;
            clusterCanvas.style.cursor = 'grabbing';
            tooltip.style.display = 'none';
        });

        window.addEventListener('mousemove', (e) => {
            if (!clusterDragging) return;
            clusterPanX = clusterDragPanX + (e.clientX - clusterDragStartX);
            clusterPanY = clusterDragPanY + (e.clientY - clusterDragStartY);
            renderCluster();
        });

        window.addEventListener('mouseup', () => {
            if (!clusterDragging) return;
            clusterDragging = false;
            if (clusterCanvas) clusterCanvas.style.cursor = clusterZoom > 1 ? 'grab' : '';
        });

        // Cluster search
        let clusterSearchTimeout;
        document.getElementById('cluster-search').addEventListener('input', (e) => {
            clearTimeout(clusterSearchTimeout);
            clusterSearchTimeout = setTimeout(() => {
                const q = e.target.value.trim().toLowerCase();
                const info = document.getElementById('cluster-search-info');
                clusterSearchMatches.clear();
                if (q.length < 2) { info.style.display = 'none'; renderCluster(); return; }
                genes.forEach((g, i) => {
                    const fid = String(g[F.FID]).toLowerCase();
                    const func = (g[F.FUNC] || '').toLowerCase();
                    if (fid.includes(q) || func.includes(q)) clusterSearchMatches.add(i);
                });
                info.textContent = `${clusterSearchMatches.size} matches`;
                info.style.display = 'block';
                renderCluster();
            }, 200);
        });

        // Resize handler
        window.addEventListener('resize', () => {
            if (activeTab === 'cluster') { resizeCluster(); renderCluster(); }
        });
    }

    // ============================================================
    // === DISTRIBUTIONS TAB ===
    // ============================================================

    function initDistributions() {
        if (distributionsLoaded) return;
        if (!genes || genes.length === 0) {
            console.error('Cannot initialize distributions: genes not loaded');
            return;
        }

        // Populate track dropdown
        const select = document.getElementById('dist-track-select');
        select.innerHTML = '<option value="">-- Choose a track --</option>';

        TRACKS.forEach(track => {
            const option = document.createElement('option');
            option.value = track.id;
            option.textContent = track.name;
            select.appendChild(option);
        });

        distributionsLoaded = true;
    }

    function renderDistributions() {
        const trackId = document.getElementById('dist-track-select').value;
        if (!trackId) {
            document.getElementById('distributions-container').innerHTML = `
                <div style="text-align: center; color: var(--kb-base-light); margin-top: 100px;">
                    <p style="font-size: 16px; margin-bottom: 8px;">ðŸ“Š Select a track to view its distribution</p>
                    <p style="font-size: 12px;">Use the dropdown in the sidebar to choose a track</p>
                </div>
            `;
            return;
        }

        const track = TRACKS.find(t => t.id === trackId);
        if (!track) return;

        const container = document.getElementById('distributions-container');

        if (track.type === 'categorical') {
            renderCategoricalDistribution(track, container);
        } else if (track.type === 'consistency') {
            renderConsistencyDistribution(track, container);
        } else if (track.type === 'sequential' || track.type === 'binary' || track.type === 'flux') {
            renderNumericalDistribution(track, container);
        }
    }

    function renderCategoricalDistribution(track, container) {
        const counts = {};
        const categories = track.categories || [];

        // Initialize counts
        if (Array.isArray(categories)) {
            categories.forEach(cat => counts[cat] = 0);
        } else if (typeof categories === 'string' && CONFIG.categories[categories]) {
            CONFIG.categories[categories].forEach(cat => counts[cat] = 0);
        } else if (track.id === 'pan_category') {
            PAN_NAMES.forEach(cat => counts[cat] = 0);
        } else if (track.id === 'localization') {
            LOC_NAMES.forEach(cat => counts[cat] = 0);
        }

        // Count genes
        genes.forEach(g => {
            let val;
            if (track.getValue) {
                val = track.getValue(g);
            } else {
                const idx = g[track.field];
                if (track.id === 'pan_category') val = PAN_NAMES[idx];
                else if (track.id === 'localization') val = LOC_NAMES[idx];
                else val = idx;
            }
            if (val !== undefined && val !== null) {
                if (counts[val] !== undefined) counts[val]++;
                else counts[val] = 1;
            }
        });

        const total = genes.length;
        const entries = Object.entries(counts).filter(([_, count]) => count > 0);

        // Generate colors
        const colors = entries.map((_, i) => COLORS.categorical(i));

        // Render
        let html = `
            <div class="dist-chart-container">
                <div class="dist-chart-title">${track.name} Distribution</div>
                <div class="dist-stats">
                    <div class="dist-stat-card">
                        <div class="dist-stat-label">Total Genes</div>
                        <div class="dist-stat-value">${total.toLocaleString()}</div>
                    </div>
                    <div class="dist-stat-card">
                        <div class="dist-stat-label">Categories</div>
                        <div class="dist-stat-value">${entries.length}</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                    <div>
                        <h3 style="font-size: 14px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 12px;">Bar Chart</h3>
                        <svg class="dist-chart-svg" id="dist-bar-chart"></svg>
                    </div>
                    <div>
                        <h3 style="font-size: 14px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 12px;">Pie Chart</h3>
                        <svg class="dist-chart-svg" id="dist-pie-chart" viewBox="0 0 400 300"></svg>
                    </div>
                </div>

                <div class="dist-legend" id="dist-legend"></div>

                <div style="margin-top: 20px;">
                    <h3 style="font-size: 14px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 8px;">Breakdown</h3>
                    <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                        <thead>
                            <tr style="background: var(--kb-base-lightest); border-bottom: 2px solid var(--kb-base-lighter);">
                                <th style="padding: 8px; text-align: left;">Category</th>
                                <th style="padding: 8px; text-align: right;">Count</th>
                                <th style="padding: 8px; text-align: right;">Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${entries.map(([cat, count], i) => `
                                <tr style="border-bottom: 1px solid var(--kb-base-lightest);">
                                    <td style="padding: 8px;">
                                        <span class="dist-legend-color" style="background: ${colors[i]}; display: inline-block; margin-right: 6px;"></span>
                                        ${cat}
                                    </td>
                                    <td style="padding: 8px; text-align: right; font-weight: 600;">${count.toLocaleString()}</td>
                                    <td style="padding: 8px; text-align: right;">${((count / total) * 100).toFixed(1)}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        `;

        container.innerHTML = html;

        // Render bar chart
        renderBarChart(entries, colors, total);

        // Render pie chart
        renderPieChart(entries, colors, total);

        // Render legend
        const legend = document.getElementById('dist-legend');
        legend.innerHTML = entries.map(([cat, count], i) => `
            <div class="dist-legend-item">
                <div class="dist-legend-color" style="background: ${colors[i]};"></div>
                <span>${cat}: ${count} (${((count / total) * 100).toFixed(1)}%)</span>
            </div>
        `).join('');
    }

    function renderBarChart(entries, colors, total) {
        const svg = document.getElementById('dist-bar-chart');
        const width = svg.clientWidth || 400;
        const height = 300;
        const margin = { top: 20, right: 20, bottom: 60, left: 60 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        const maxCount = Math.max(...entries.map(([_, count]) => count));
        const barWidth = chartWidth / entries.length;

        let svgContent = `<svg width="${width}" height="${height}">`;

        // Bars
        entries.forEach(([cat, count], i) => {
            const barHeight = (count / maxCount) * chartHeight;
            const x = margin.left + i * barWidth + barWidth * 0.1;
            const y = margin.top + chartHeight - barHeight;
            const w = barWidth * 0.8;

            svgContent += `
                <rect x="${x}" y="${y}" width="${w}" height="${barHeight}"
                      fill="${colors[i]}" class="dist-bar">
                    <title>${cat}: ${count} genes (${((count / total) * 100).toFixed(1)}%)</title>
                </rect>
            `;
        });

        // Y-axis
        svgContent += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + chartHeight}" stroke="var(--kb-base-light)" stroke-width="1"/>`;

        // X-axis
        svgContent += `<line x1="${margin.left}" y1="${margin.top + chartHeight}" x2="${margin.left + chartWidth}" y2="${margin.top + chartHeight}" stroke="var(--kb-base-light)" stroke-width="1"/>`;

        // Y-axis ticks
        for (let i = 0; i <= 5; i++) {
            const y = margin.top + chartHeight - (i / 5) * chartHeight;
            const val = Math.round((i / 5) * maxCount);
            svgContent += `
                <line x1="${margin.left - 5}" y1="${y}" x2="${margin.left}" y2="${y}" stroke="var(--kb-base-light)" stroke-width="1"/>
                <text x="${margin.left - 10}" y="${y + 4}" text-anchor="end" font-size="10" fill="var(--kb-base)">${val}</text>
            `;
        }

        // X-axis labels (abbreviated if needed)
        entries.forEach(([cat, _], i) => {
            const x = margin.left + i * barWidth + barWidth * 0.5;
            const label = cat.length > 10 ? cat.substring(0, 8) + '...' : cat;
            svgContent += `
                <text x="${x}" y="${margin.top + chartHeight + 15}"
                      text-anchor="middle" font-size="10" fill="var(--kb-base)"
                      transform="rotate(45, ${x}, ${margin.top + chartHeight + 15})">${label}</text>
            `;
        });

        svgContent += '</svg>';
        svg.innerHTML = svgContent;
    }

    function renderPieChart(entries, colors, total) {
        const svg = document.getElementById('dist-pie-chart');
        const cx = 200, cy = 150, radius = 100;

        let currentAngle = -Math.PI / 2;
        let svgContent = '<g>';

        entries.forEach(([cat, count], i) => {
            const angle = (count / total) * 2 * Math.PI;
            const endAngle = currentAngle + angle;

            const x1 = cx + radius * Math.cos(currentAngle);
            const y1 = cy + radius * Math.sin(currentAngle);
            const x2 = cx + radius * Math.cos(endAngle);
            const y2 = cy + radius * Math.sin(endAngle);

            const largeArc = angle > Math.PI ? 1 : 0;

            svgContent += `
                <path d="M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z"
                      fill="${colors[i]}" stroke="white" stroke-width="2" class="dist-bar">
                    <title>${cat}: ${count} genes (${((count / total) * 100).toFixed(1)}%)</title>
                </path>
            `;

            currentAngle = endAngle;
        });

        svgContent += '</g>';
        svg.innerHTML = svgContent;
    }

    function renderConsistencyDistribution(track, container) {
        const values = [];
        const naCount = { count: 0 };

        genes.forEach(g => {
            const val = g[track.field];
            if (val < 0) naCount.count++;
            else values.push(val);
        });

        renderHistogram(track, values, naCount, container);
    }

    function renderNumericalDistribution(track, container) {
        const values = [];

        genes.forEach(g => {
            let val;
            if (track.getValue) {
                val = track.getValue(g);
            } else {
                val = g[track.field];
            }
            if (val !== undefined && val !== null && !isNaN(val)) {
                values.push(Number(val));
            }
        });

        renderHistogram(track, values, null, container);
    }

    function renderHistogram(track, values, naCount, container) {
        const total = genes.length;
        const nBins = Math.min(20, Math.max(10, Math.ceil(Math.sqrt(values.length))));

        const min = Math.min(...values);
        const max = Math.max(...values);
        const binWidth = (max - min) / nBins;

        const bins = Array(nBins).fill(0);
        values.forEach(v => {
            const binIdx = Math.min(Math.floor((v - min) / binWidth), nBins - 1);
            bins[binIdx]++;
        });

        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const sorted = [...values].sort((a, b) => a - b);
        const median = sorted[Math.floor(sorted.length / 2)];

        let html = `
            <div class="dist-chart-container">
                <div class="dist-chart-title">${track.name} Distribution</div>
                <div class="dist-stats">
                    <div class="dist-stat-card">
                        <div class="dist-stat-label">Total Genes</div>
                        <div class="dist-stat-value">${values.length.toLocaleString()}</div>
                    </div>
                    ${naCount ? `
                    <div class="dist-stat-card" style="border-left-color: var(--kb-base-light);">
                        <div class="dist-stat-label">N/A</div>
                        <div class="dist-stat-value">${naCount.count.toLocaleString()}</div>
                    </div>
                    ` : ''}
                    <div class="dist-stat-card" style="border-left-color: var(--kb-accent);">
                        <div class="dist-stat-label">Mean</div>
                        <div class="dist-stat-value">${mean.toFixed(3)}</div>
                    </div>
                    <div class="dist-stat-card" style="border-left-color: var(--kb-accent);">
                        <div class="dist-stat-label">Median</div>
                        <div class="dist-stat-value">${median.toFixed(3)}</div>
                    </div>
                    <div class="dist-stat-card" style="border-left-color: var(--kb-accent);">
                        <div class="dist-stat-label">Min / Max</div>
                        <div class="dist-stat-value" style="font-size: 16px;">${min.toFixed(2)} / ${max.toFixed(2)}</div>
                    </div>
                </div>

                <h3 style="font-size: 14px; font-weight: 600; color: var(--kb-base-dark); margin-bottom: 12px;">Histogram</h3>
                <svg class="dist-chart-svg" id="dist-histogram" style="height: 350px;"></svg>
            </div>
        `;

        container.innerHTML = html;

        // Render histogram
        const svg = document.getElementById('dist-histogram');
        const width = svg.clientWidth || 600;
        const height = 350;
        const margin = { top: 20, right: 20, bottom: 60, left: 60 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        const maxBinCount = Math.max(...bins);
        const barWidth = chartWidth / nBins;

        let svgContent = `<svg width="${width}" height="${height}">`;

        // Bars
        bins.forEach((count, i) => {
            const barHeight = (count / maxBinCount) * chartHeight;
            const x = margin.left + i * barWidth;
            const y = margin.top + chartHeight - barHeight;
            const binStart = min + i * binWidth;
            const binEnd = binStart + binWidth;

            svgContent += `
                <rect x="${x}" y="${y}" width="${barWidth * 0.95}" height="${barHeight}"
                      fill="var(--kb-primary)" opacity="0.8" class="dist-bar">
                    <title>${binStart.toFixed(2)} - ${binEnd.toFixed(2)}: ${count} genes</title>
                </rect>
            `;
        });

        // Y-axis
        svgContent += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + chartHeight}" stroke="var(--kb-base-light)" stroke-width="1"/>`;

        // X-axis
        svgContent += `<line x1="${margin.left}" y1="${margin.top + chartHeight}" x2="${margin.left + chartWidth}" y2="${margin.top + chartHeight}" stroke="var(--kb-base-light)" stroke-width="1"/>`;

        // Y-axis label
        svgContent += `<text x="${margin.left - 45}" y="${margin.top + chartHeight / 2}" text-anchor="middle" font-size="12" fill="var(--kb-base)" transform="rotate(-90, ${margin.left - 45}, ${margin.top + chartHeight / 2})">Gene Count</text>`;

        // X-axis label
        svgContent += `<text x="${margin.left + chartWidth / 2}" y="${height - 10}" text-anchor="middle" font-size="12" fill="var(--kb-base)">${track.name}</text>`;

        // Y-axis ticks
        for (let i = 0; i <= 5; i++) {
            const y = margin.top + chartHeight - (i / 5) * chartHeight;
            const val = Math.round((i / 5) * maxBinCount);
            svgContent += `
                <line x1="${margin.left - 5}" y1="${y}" x2="${margin.left}" y2="${y}" stroke="var(--kb-base-light)" stroke-width="1"/>
                <text x="${margin.left - 10}" y="${y + 4}" text-anchor="end" font-size="10" fill="var(--kb-base)">${val}</text>
            `;
        }

        // X-axis ticks
        for (let i = 0; i <= nBins; i += Math.max(1, Math.floor(nBins / 8))) {
            const x = margin.left + i * barWidth;
            const val = min + i * binWidth;
            svgContent += `
                <line x1="${x}" y1="${margin.top + chartHeight}" x2="${x}" y2="${margin.top + chartHeight + 5}" stroke="var(--kb-base-light)" stroke-width="1"/>
                <text x="${x}" y="${margin.top + chartHeight + 18}" text-anchor="middle" font-size="10" fill="var(--kb-base)">${val.toFixed(2)}</text>
            `;
        }

        svgContent += '</svg>';
        svg.innerHTML = svgContent;
    }

    // ============================================================
    // === METABOLIC MAP VIEW ===
    // ============================================================

    function loadEscherLibrary() {
        return new Promise((resolve, reject) => {
            if (window.escher) return resolve();
            // Load D3 first (Escher needs it)
            const d3Script = document.createElement('script');
            d3Script.src = 'https://unpkg.com/d3@5.16.0/dist/d3.min.js';
            d3Script.onload = () => {
                const escherScript = document.createElement('script');
                escherScript.src = 'https://unpkg.com/escher@1.7.3/dist/escher.min.js';
                escherScript.onload = resolve;
                escherScript.onerror = reject;
                document.head.appendChild(escherScript);
            };
            d3Script.onerror = reject;
            document.head.appendChild(d3Script);
        });
    }

    // Load just reactions data (for metabolic tracks) - called on page load
    async function loadReactionsData() {
        try {
            const rxnFile = (CONFIG && CONFIG.data_files && CONFIG.data_files.reactions) || 'reactions_data.json';
            const rxnResp = await fetch(rxnFile);
            reactionsData = await rxnResp.json();
            computeGeneMetabolicProperties();  // Compute flux/class for each gene
            console.log('âœ“ Loaded reactions data:', Object.keys(reactionsData.reactions).length, 'reactions');
        } catch (e) {
            console.warn('Reactions data not available:', e);
            // Not a critical error - metabolic tracks just won't work
        }
    }

    async function loadMetabolicData() {
        const loading = document.getElementById('metabolic-loading');
        loading.textContent = 'Loading Escher library and metabolic map...';
        try {
            // Reactions data already loaded during page init, just load Escher + map
            if (!reactionsData) {
                await loadReactionsData();  // Fallback if it failed earlier
            }

            const mapConfig = (CONFIG && CONFIG.data_files && CONFIG.data_files.metabolic_maps && CONFIG.data_files.metabolic_maps[currentMapId]) || {};
            const mapFile = mapConfig.file || 'metabolic_map_full.json';

            const [_, mapResp] = await Promise.all([
                loadEscherLibrary(),
                fetch(mapFile)
            ]);
            const mapData = await mapResp.json();
            cachedMaps[currentMapId] = mapData;
            metabolicLoaded = true;
            loading.style.display = 'none';
            initEscherMap(mapData);
            renderMetabolicStats();
            renderMetabolicLegend();
            renderPathwayCoverage();
            updateMetabolicToolbar();
        } catch (e) {
            console.error('Failed to load metabolic data:', e);
            loading.textContent = 'Error loading metabolic data. Check console.';
        }
    }

    // Compute gene-level metabolic properties from reactions
    // Store in geneMetabolicProps map: geneId -> {flux_rich, flux_min, class_rich, class_min}
    let geneMetabolicProps = new Map();

    function computeGeneMetabolicProperties() {
        if (!reactionsData || !reactionsData.gene_index) return;

        const classRank = {
            'essential_forward': 6,
            'essential_reverse': 5,
            'forward_only': 4,
            'reverse_only': 3,
            'reversible': 2,
            'blocked': 1
        };

        // For each gene, aggregate flux and class from all associated reactions
        for (const [geneId, rxnIndices] of Object.entries(reactionsData.gene_index)) {
            let maxFluxRich = 0;
            let maxFluxMin = 0;
            let bestClassRich = 'blocked';
            let bestClassMin = 'blocked';
            let bestRankRich = 0;
            let bestRankMin = 0;

            // Get all reactions for this gene
            const rxnIds = Object.keys(reactionsData.reactions);
            for (const rxnIdx of rxnIndices) {
                const rxnId = rxnIds[rxnIdx];
                const rxn = reactionsData.reactions[rxnId];
                if (!rxn) continue;

                // Track max absolute flux
                const absFluxRich = Math.abs(rxn.flux_rich || 0);
                const absFluxMin = Math.abs(rxn.flux_min || 0);
                if (absFluxRich > Math.abs(maxFluxRich)) maxFluxRich = rxn.flux_rich || 0;
                if (absFluxMin > Math.abs(maxFluxMin)) maxFluxMin = rxn.flux_min || 0;

                // Track most important class (essential > active > blocked)
                const rankRich = classRank[rxn.class_rich] || 0;
                const rankMin = classRank[rxn.class_min] || 0;
                if (rankRich > bestRankRich) {
                    bestRankRich = rankRich;
                    bestClassRich = rxn.class_rich || 'blocked';
                }
                if (rankMin > bestRankMin) {
                    bestRankMin = rankMin;
                    bestClassMin = rxn.class_min || 'blocked';
                }
            }

            geneMetabolicProps.set(geneId, {
                flux_rich: maxFluxRich,
                flux_min: maxFluxMin,
                class_rich: bestClassRich,
                class_min: bestClassMin
            });
        }

        console.log(`Computed metabolic properties for ${geneMetabolicProps.size} genes`);
    }

    function initEscherMap(mapData) {
        const container = document.getElementById('metabolic-container');
        // Clear all previous content (Escher creates its own structure)
        container.innerHTML = '';

        const reactionData = buildReactionColorData(metabolicColorBy);
        const scale = getReactionScale(metabolicColorBy);

        try {
            escherBuilder = escher.Builder(mapData, null, null, d3.select(container), {
                menu: 'zoom',
                scroll_behavior: 'zoom',
                fill_screen: false,
                reaction_data: reactionData,
                reaction_styles: ['color', 'size'],
                reaction_scale: scale,
                never_ask_before_quit: true,
                enable_editing: false,
                enable_keys: false,
            });
            // Wire click events on reactions
            setupMetabolicClickEvents();
        } catch (e) {
            console.error('Escher Builder error:', e);
            container.innerHTML = '<div class="metabolic-loading">Error initializing Escher map. See console.</div>';
        }
    }

    function buildReactionColorData(colorBy) {
        if (!reactionsData) return {};
        const data = {};

        // For each of our reactions, map to ALL possible Escher ID formats
        for (const [rxnId, rxn] of Object.entries(reactionsData.reactions)) {
            let value;
            switch (colorBy) {
                case 'conservation': value = rxn.conservation; break;
                case 'presence': value = 1; break;
                case 'flux_rich': value = rxn.flux_rich; break;
                case 'flux_min': value = rxn.flux_min; break;
                case 'class_rich': value = FLUX_CLASSES.indexOf(rxn.class_rich); break;
                case 'class_min': value = FLUX_CLASSES.indexOf(rxn.class_min); break;
            }

            // Escher accepts multiple ID formats - add all variations
            // 1. Base ID (rxn00225)
            data[rxnId] = value;

            // 2. With common compartments (rxn00225_c0, rxn00225_e0, etc.)
            const compartments = ['c0', 'e0', 'p0', 'm0', 'x0'];
            for (const comp of compartments) {
                data[`${rxnId}_${comp}`] = value;
            }
        }
        return data;
    }

    function getReactionScale(colorBy) {
        switch (colorBy) {
            case 'conservation':
                return [
                    { type: 'min', color: '#e5e7eb', size: 6 },
                    { type: 'value', value: 0.2, color: '#93c5fd', size: 8 },
                    { type: 'value', value: 0.8, color: '#2563eb', size: 10 },
                    { type: 'max', color: '#166534', size: 12 }
                ];
            case 'presence':
                return [
                    { type: 'min', color: '#22c55e', size: 10 },
                    { type: 'max', color: '#22c55e', size: 10 }
                ];
            case 'flux_rich': case 'flux_min':
                return [
                    { type: 'min', color: '#3b82f6', size: 12 },
                    { type: 'value', value: 0, color: '#f3f4f6', size: 6 },
                    { type: 'max', color: '#ef4444', size: 12 }
                ];
            case 'class_rich': case 'class_min':
                return [
                    { type: 'value', value: 0, color: FLUX_CLASS_COLORS.blocked, size: 6 },
                    { type: 'value', value: 1, color: FLUX_CLASS_COLORS.forward_only, size: 10 },
                    { type: 'value', value: 2, color: FLUX_CLASS_COLORS.reverse_only, size: 10 },
                    { type: 'value', value: 3, color: FLUX_CLASS_COLORS.reversible, size: 10 },
                    { type: 'value', value: 4, color: FLUX_CLASS_COLORS.essential_forward, size: 12 },
                    { type: 'value', value: 5, color: FLUX_CLASS_COLORS.essential_reverse, size: 12 }
                ];
            default: return [];
        }
    }

    function renderMetabolicLegend() {
        const el = document.getElementById('metabolic-legend');
        let html = '';
        switch (metabolicColorBy) {
            case 'conservation':
                html = `
                    <div class="legend-row"><div class="legend-swatch" style="background:#e5e7eb"></div> Absent (0%)</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#93c5fd"></div> Low (&lt;20%)</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#2563eb"></div> Moderate (20-80%)</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#166534"></div> High (&gt;80%)</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#f3f4f6; border:1px dashed #ccc"></div> No data (not in model)</div>`;
                break;
            case 'presence':
                html = `
                    <div class="legend-row"><div class="legend-swatch" style="background:#22c55e"></div> Present in user genome</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#f3f4f6; border:1px dashed #ccc"></div> Absent / No data</div>`;
                break;
            case 'flux_rich': case 'flux_min':
                const media = metabolicColorBy === 'flux_rich' ? 'rich' : 'minimal';
                html = `
                    <div class="legend-row"><div class="legend-swatch" style="background:#3b82f6"></div> Reverse flux</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#f3f4f6"></div> Zero flux</div>
                    <div class="legend-row"><div class="legend-swatch" style="background:#ef4444"></div> Forward flux</div>
                    <div class="legend-row" style="margin-top:2px; color:#9D9389; font-size:9px">FBA solution on ${media} media</div>`;
                break;
            case 'class_rich': case 'class_min':
                for (const cls of FLUX_CLASSES) {
                    html += `<div class="legend-row"><div class="legend-swatch" style="background:${FLUX_CLASS_COLORS[cls]}"></div> ${FLUX_CLASS_LABELS[cls]}</div>`;
                }
                break;
        }
        el.innerHTML = html;
    }

    function renderMetabolicStats() {
        if (!reactionsData) return;
        const stats = reactionsData.stats;
        // Count how many reactions on current map
        const mapData = cachedMaps[currentMapId];
        let onMap = 0, withData = 0;
        const onMapSet = new Set();
        if (mapData && mapData[1] && mapData[1].reactions) {
            const mapRxns = mapData[1].reactions;
            const totalOnMap = Object.keys(mapRxns).length;
            for (const k of Object.keys(mapRxns)) {
                const biggId = mapRxns[k].bigg_id;
                // Strip compartment suffix (_c0, _e0, etc.) to match our base IDs
                const baseId = biggId.replace(/_[cepxm]\d+$/, '');
                if (reactionsData.reactions[baseId]) {
                    withData++;
                    onMap++;
                    onMapSet.add(baseId);
                }
                else onMap++;
            }
            const notOnMap = stats.total_reactions - withData;
            document.getElementById('metabolic-stats').innerHTML = `
                <div><strong>${stats.total_reactions}</strong> user genome reactions</div>
                <div style="margin-top:4px;"><strong>${withData}</strong> shown on map (of ${totalOnMap} on map)</div>
                <div><strong>${notOnMap}</strong> not on map</div>
                <div style="margin-top:6px; border-top:1px solid #DED5CB; padding-top:6px;">
                    <div>Active (rich): <strong>${stats.active_rich}</strong></div>
                    <div>Active (minimal): <strong>${stats.active_min}</strong></div>
                    <div>Essential (rich): <strong>${stats.essential_rich}</strong></div>
                    <div>Essential (minimal): <strong>${stats.essential_min}</strong></div>
                    <div>Blocked (rich): <strong>${stats.blocked_rich}</strong></div>
                </div>
                <div style="margin-top:4px; font-size:10px; color:#9D9389;">
                    Data from ${reactionsData.n_genomes} genomes
                </div>
            `;
            renderUnmappedReactions(onMapSet);
        }
    }

    function renderUnmappedReactions(onMapSet) {
        if (!reactionsData) return;

        // Find all reactions NOT on the current map (excluding exchange and sink reactions)
        const unmapped = [];
        for (const [rxnId, rxn] of Object.entries(reactionsData.reactions)) {
            // Filter out reactions on map, and also filter out exchange (EX_) and sink (SK_) reactions
            if (!onMapSet.has(rxnId) && !rxnId.startsWith('EX_') && !rxnId.startsWith('SK_')) {
                unmapped.push({ id: rxnId, ...rxn });
            }
        }

        // Sort by ID for easy browsing
        unmapped.sort((a, b) => a.id.localeCompare(b.id));

        const el = document.getElementById('metabolic-unmapped');
        if (unmapped.length === 0) {
            el.innerHTML = '<span style="color:#9D9389;">All reactions are on this map</span>';
            return;
        }

        // Show first 50, with option to see all
        const maxShow = 50;
        const showAll = unmapped.length <= maxShow;
        const toShow = showAll ? unmapped : unmapped.slice(0, maxShow);

        let html = `<div style="margin-bottom:6px; font-weight:600;">${unmapped.length} metabolic reactions not on map:</div>`;
        html += '<div style="font-family: monospace; line-height: 1.6;">';

        for (const rxn of toShow) {
            const hasGenes = rxn.genes && rxn.genes.trim() !== '';
            const label = hasGenes ? `(${rxn.genes.split(/\s+or\s+|\s+and\s+/).length} genes)` : '(no genes)';
            const eq = rxn.equation || 'No equation available';
            html += `<div style="margin-bottom:2px;"><span style="color:var(--kb-accent); cursor:help;" title="${eq}">${rxn.id}</span> <span style="color:#9D9389; font-size:9px;">${label}</span></div>`;
        }

        if (!showAll) {
            html += `<div style="margin-top:8px; padding-top:6px; border-top:1px solid #DED5CB; color:var(--kb-accent); cursor:pointer;" onclick="showAllUnmappedReactions()">+ Show all ${unmapped.length} unmapped reactions</div>`;
        }

        html += '</div>';
        el.innerHTML = html;
    }

    function showAllUnmappedReactions() {
        // Rebuild with all reactions
        const mapData = cachedMaps[currentMapId];
        const onMapSet = new Set();
        if (mapData && mapData[1] && mapData[1].reactions) {
            const mapRxns = mapData[1].reactions;
            for (const k of Object.keys(mapRxns)) {
                const biggId = mapRxns[k].bigg_id;
                const baseId = biggId.replace(/_[cepxm]\d+$/, '');
                if (reactionsData.reactions[baseId]) {
                    onMapSet.add(baseId);
                }
            }
        }

        const unmapped = [];
        for (const [rxnId, rxn] of Object.entries(reactionsData.reactions)) {
            // Filter out exchange (EX_) and sink (SK_) reactions
            if (!onMapSet.has(rxnId) && !rxnId.startsWith('EX_') && !rxnId.startsWith('SK_')) {
                unmapped.push({ id: rxnId, ...rxn });
            }
        }
        unmapped.sort((a, b) => a.id.localeCompare(b.id));

        const el = document.getElementById('metabolic-unmapped');
        let html = `<div style="margin-bottom:6px; font-weight:600;">${unmapped.length} metabolic reactions not on map:</div>`;
        html += '<div style="font-family: monospace; line-height: 1.6;">';

        for (const rxn of unmapped) {
            const hasGenes = rxn.genes && rxn.genes.trim() !== '';
            const label = hasGenes ? `(${rxn.genes.split(/\s+or\s+|\s+and\s+/).length} genes)` : '(no genes)';
            html += `<div style="margin-bottom:2px;"><span style="color:var(--kb-accent)">${rxn.id}</span> <span style="color:#9D9389; font-size:9px;">${label}</span></div>`;
        }

        html += '</div>';
        el.innerHTML = html;
    }

    function renderPathwayCoverage() {
        const container = document.getElementById('pathway-coverage');

        if (!genes || genes.length === 0) {
            container.innerHTML = '<span style="color:#9D9389;">No gene data loaded</span>';
            return;
        }

        const totalGenes = genes.length;

        // Count genes with KO annotations (metabolic genes)
        // Use N_KO as proxy since N_MODULES may not be populated
        const koCount = { 'none': 0, 'low': 0, 'medium': 0, 'high': 0 };

        genes.forEach(g => {
            const nKO = g[F.N_KO] || 0;
            if (nKO === 0) koCount.none++;
            else if (nKO === 1) koCount.low++;
            else if (nKO <= 3) koCount.medium++;
            else koCount.high++;
        });

        // Calculate metabolic coverage statistics
        const metabolicGenes = totalGenes - koCount.none;
        const metabolicPct = ((metabolicGenes / totalGenes) * 100).toFixed(1);

        // Count genes with EC, KO annotations (pathway-relevant)
        const withEC = genes.filter(g => g[F.N_EC] > 0).length;
        const withKO = genes.filter(g => g[F.N_KO] > 0).length;
        const ecPct = ((withEC / totalGenes) * 100).toFixed(1);
        const koPct = ((withKO / totalGenes) * 100).toFixed(1);

        // Get gapfilled reactions count
        let gapfilledCount = 0;
        if (reactionsData && reactionsData.reactions) {
            for (const rxn of Object.values(reactionsData.reactions)) {
                if (rxn.gapfilling && rxn.gapfilling !== 'none') {
                    gapfilledCount++;
                }
            }
        }

        let html = `
            <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid var(--kb-base-lightest);">
                <div style="font-weight:600; margin-bottom:6px; color:var(--kb-base-dark);">Metabolic Coverage</div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px;">
                    <div style="padding:6px; background:var(--kb-base-lightest); border-radius:3px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:2px;">KEGG Annotated</div>
                        <div style="font-size:16px; font-weight:700; color:#3b82f6;">${metabolicGenes}</div>
                        <div style="font-size:9px; color:var(--kb-base);">${metabolicPct}% of genome</div>
                    </div>
                    <div style="padding:6px; background:var(--kb-base-lightest); border-radius:3px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:2px;">Gapfilled</div>
                        <div style="font-size:16px; font-weight:700; color:#f59e0b;">${gapfilledCount}</div>
                        <div style="font-size:9px; color:var(--kb-base);">reactions inferred</div>
                    </div>
                </div>
            </div>

            <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid var(--kb-base-lightest);">
                <div style="font-weight:600; margin-bottom:6px; color:var(--kb-base-dark);">Annotation Depth</div>
                <div style="margin-bottom:6px;">
                    <div style="display:flex; justify-content:space-between; font-size:10px; margin-bottom:2px;">
                        <span>KEGG Orthology (KO)</span>
                        <span style="font-weight:600;">${withKO} (${koPct}%)</span>
                    </div>
                    <div style="background:var(--kb-base-lightest); height:12px; border-radius:2px; overflow:hidden;">
                        <div style="background:#8b5cf6; height:100%; width:${koPct}%; opacity:0.8;"></div>
                    </div>
                </div>
                <div>
                    <div style="display:flex; justify-content:space-between; font-size:10px; margin-bottom:2px;">
                        <span>EC Numbers</span>
                        <span style="font-weight:600;">${withEC} (${ecPct}%)</span>
                    </div>
                    <div style="background:var(--kb-base-lightest); height:12px; border-radius:2px; overflow:hidden;">
                        <div style="background:#22c55e; height:100%; width:${ecPct}%; opacity:0.8;"></div>
                    </div>
                </div>
            </div>

            <div>
                <div style="font-weight:600; margin-bottom:6px; color:var(--kb-base-dark);">KEGG Annotation Depth</div>
                <div style="font-size:10px; line-height:1.6;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span style="color:var(--kb-base);">No KO terms:</span>
                        <span style="font-weight:600; color:var(--kb-base-dark);">${koCount.none} genes</span>
                    </div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span style="color:var(--kb-base);">1 KO term:</span>
                        <span style="font-weight:600; color:var(--kb-base-dark);">${koCount.low} genes</span>
                    </div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span style="color:var(--kb-base);">2-3 KO terms:</span>
                        <span style="font-weight:600; color:var(--kb-base-dark);">${koCount.medium} genes</span>
                    </div>
                    <div style="display:flex; justify-content:space-between;">
                        <span style="color:var(--kb-base);">4+ KO terms:</span>
                        <span style="font-weight:600; color:var(--kb-base-dark);">${koCount.high} genes</span>
                    </div>
                </div>
            </div>

            <div style="margin-top:12px; padding:8px; background:#fef3c7; border-left:3px solid #f59e0b; border-radius:3px; font-size:10px; line-height:1.4;">
                <div style="font-weight:600; margin-bottom:4px; color:#92400e;">Gapfilled Reactions</div>
                <div style="color:#92400e;">Reactions shown with dashed outline are computationally inferred (no gene support). Filter by gapfilling status in reaction table.</div>
            </div>
        `;

        container.innerHTML = html;
    }

    function exportReactions() {
        if (!reactionsData) {
            alert('Reactions data not loaded yet');
            return;
        }

        const headers = ['Reaction_ID', 'Equation', 'Genes', 'Conservation', 'Directionality', 'Flux_Rich', 'Class_Rich', 'Flux_Min', 'Class_Min', 'Gapfilling'];
        const rows = [headers.join(',')];

        for (const [rxnId, rxn] of Object.entries(reactionsData.reactions)) {
            const eq = (rxn.equation || '').replace(/,/g, ';').replace(/"/g, '""');
            const genes = (rxn.genes || '').replace(/,/g, ';').replace(/"/g, '""');
            const cons = rxn.conservation || 0;
            const dir = rxn.directionality || '';
            const fluxRich = rxn.flux_rich || 0;
            const classRich = rxn.class_rich || '';
            const fluxMin = rxn.flux_min || 0;
            const classMin = rxn.class_min || '';
            const gap = rxn.gapfilling || 'none';

            rows.push(`${rxnId},"${eq}","${genes}",${cons},${dir},${fluxRich},${classRich},${fluxMin},${classMin},${gap}`);
        }

        const csv = rows.join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `reactions_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // Reaction Table Functions
    let reactionTableVisible = false;
    let filteredReactions = [];

    function toggleReactionTable() {
        reactionTableVisible = !reactionTableVisible;
        const mapContainer = document.getElementById('metabolic-container');
        const tableContainer = document.getElementById('reaction-table-container');
        const toggleIcon = document.getElementById('table-toggle-icon');
        const toggleText = document.getElementById('table-toggle-text');

        if (reactionTableVisible) {
            mapContainer.style.display = 'none';
            tableContainer.style.display = 'flex';
            toggleIcon.innerHTML = '&#128506;'; // map icon
            toggleText.textContent = 'Show map';
            renderReactionTable();
        } else {
            mapContainer.style.display = 'flex';
            tableContainer.style.display = 'none';
            toggleIcon.innerHTML = '&#9776;'; // table icon
            toggleText.textContent = 'Show reaction table';
        }
    }

    function renderReactionTable() {
        if (!reactionsData) return;

        // Get filter, sort, and search preferences
        const filter = document.getElementById('rxn-table-filter').value;
        const sort = document.getElementById('rxn-table-sort').value;
        const searchInput = document.getElementById('rxn-table-search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

        // Determine which reactions are on map
        const onMapSet = new Set();
        const mapData = cachedMaps[currentMapId];
        if (mapData && mapData[1] && mapData[1].reactions) {
            for (const k of Object.keys(mapData[1].reactions)) {
                const biggId = mapData[1].reactions[k].bigg_id;
                const baseId = biggId.replace(/_[cepxm]\d+$/, '');
                if (reactionsData.reactions[baseId]) {
                    onMapSet.add(baseId);
                }
            }
        }

        // Filter reactions
        filteredReactions = [];
        for (const [rxnId, rxn] of Object.entries(reactionsData.reactions)) {
            let include = false;
            const hasGenes = rxn.genes && rxn.genes.trim() !== '';
            const isExchange = rxnId.startsWith('EX_') || rxnId.startsWith('SK_');
            const isOnMap = onMapSet.has(rxnId);
            const isGapfilled = rxn.gapfilling && rxn.gapfilling !== 'none';

            // Apply dropdown filter
            switch (filter) {
                case 'all': include = true; break;
                case 'metabolic': include = !isExchange; break;
                case 'on_map': include = isOnMap; break;
                case 'not_on_map': include = !isOnMap; break;
                case 'has_genes': include = hasGenes; break;
                case 'no_genes': include = !hasGenes; break;
                case 'gapfilled': include = isGapfilled; break;
                case 'gene_supported': include = !isGapfilled && hasGenes; break;
                case 'exchange': include = isExchange; break;
            }

            // Apply search term filter (if present)
            if (include && searchTerm) {
                const matchesId = rxnId.toLowerCase().includes(searchTerm);
                const matchesEq = (rxn.equation || '').toLowerCase().includes(searchTerm);
                const matchesGenes = (rxn.genes || '').toLowerCase().includes(searchTerm);
                include = matchesId || matchesEq || matchesGenes;
            }

            if (include) {
                filteredReactions.push({ id: rxnId, ...rxn });
            }
        }

        // Sort reactions
        filteredReactions.sort((a, b) => {
            switch (sort) {
                case 'id': return a.id.localeCompare(b.id);
                case 'conservation': return (b.conservation || 0) - (a.conservation || 0);
                case 'flux_rich': return Math.abs(b.flux_rich || 0) - Math.abs(a.flux_rich || 0);
                case 'flux_min': return Math.abs(b.flux_min || 0) - Math.abs(a.flux_min || 0);
                default: return 0;
            }
        });

        // Render table
        const tbody = document.getElementById('reaction-table-body');
        if (filteredReactions.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align:center; padding:20px; color:#9D9389;">No reactions match this filter</td></tr>';
        } else {
            let html = '';
            for (const rxn of filteredReactions) {
                const eq = rxn.equation || '';
                const genes = rxn.genes || 'No genes';
                const cons = ((rxn.conservation || 0) * 100).toFixed(0) + '%';
                const fluxR = (rxn.flux_rich || 0).toFixed(3);
                const classR = rxn.class_rich || '-';
                const fluxM = (rxn.flux_min || 0).toFixed(3);
                const classM = rxn.class_min || '-';
                const isGapfilled = rxn.gapfilling && rxn.gapfilling !== 'none';
                const gapfillBadge = isGapfilled ? '<span style="background:#fbbf24; color:#78350f; padding:1px 4px; border-radius:2px; font-size:9px; font-weight:600; margin-left:4px;">GAP</span>' : '';

                html += `<tr${isGapfilled ? ' style="background:#fef3c722;"' : ''}>
                    <td class="rxn-id-col" title="${eq}">${rxn.id}${gapfillBadge}</td>
                    <td class="rxn-eq-col" title="${eq}">${eq}</td>
                    <td class="rxn-genes-col" title="${genes}">${genes}</td>
                    <td>${cons}</td>
                    <td>${fluxR}</td>
                    <td>${classR}</td>
                    <td>${fluxM}</td>
                    <td>${classM}</td>
                </tr>`;
            }
            tbody.innerHTML = html;
        }

        // Update count
        document.getElementById('rxn-table-count').textContent = `Showing ${filteredReactions.length} reactions`;
    }

    function filterReactionTable() {
        renderReactionTable();
    }

    function sortReactionTable() {
        renderReactionTable();
    }

    function updateMetabolicToolbar() {
        const mapName = (CONFIG && CONFIG.data_files && CONFIG.data_files.metabolic_maps &&
            CONFIG.data_files.metabolic_maps[currentMapId] && CONFIG.data_files.metabolic_maps[currentMapId].name) || currentMapId;
        document.getElementById('metabolic-toolbar-info').textContent = `${mapName} - ${Object.keys(reactionsData.reactions).length} reactions`;
    }

    async function changeMetabolicMap() {
        currentMapId = document.getElementById('metabolic-map-select').value;
        if (cachedMaps[currentMapId]) {
            initEscherMap(cachedMaps[currentMapId]);
            renderMetabolicStats();
            renderPathwayCoverage();
            updateMetabolicToolbar();
        } else {
            const mapConfig = (CONFIG && CONFIG.data_files && CONFIG.data_files.metabolic_maps && CONFIG.data_files.metabolic_maps[currentMapId]) || {};
            const mapFile = mapConfig.file || `metabolic_map_${currentMapId}.json`;
            try {
                const resp = await fetch(mapFile);
                const mapData = await resp.json();
                cachedMaps[currentMapId] = mapData;
                initEscherMap(mapData);
                renderMetabolicStats();
                renderPathwayCoverage();
                updateMetabolicToolbar();
            } catch (e) {
                console.error('Failed to load map:', e);
            }
        }
    }

    function changeMetabolicColor() {
        metabolicColorBy = document.getElementById('metabolic-color-by').value;
        if (escherBuilder) {
            const data = buildReactionColorData(metabolicColorBy);
            const scale = getReactionScale(metabolicColorBy);
            escherBuilder.set_reaction_data(data);
            // Rebuild with new scale (Escher doesn't have a set_reaction_scale API)
            // So we reinitialize with the cached map
            if (cachedMaps[currentMapId]) {
                initEscherMap(cachedMaps[currentMapId]);
            }
        }
        renderMetabolicLegend();
    }

    function setupMetabolicClickEvents() {
        // Listen for clicks on reaction labels in the Escher SVG
        setTimeout(() => {
            const container = document.getElementById('metabolic-container');
            const svg = container.querySelector('svg');
            if (!svg) return;

            svg.addEventListener('click', (e) => {
                // Walk up from click target to find a .reaction group
                const rxnGroup = e.target.closest('.reaction');
                if (!rxnGroup) return;
                // Get reaction ID from the label text inside this group
                const label = rxnGroup.querySelector('.reaction-label');
                const rxnId = label ? label.textContent.trim() : null;
                if (rxnId) showReactionDetail(rxnId);
            });
        }, 500);
    }

    function showReactionDetail(rxnId) {
        // Strip compartment suffix to match our data format
        const baseId = rxnId.replace(/_[cepxm]\d+$/, '');
        const rxn = reactionsData && reactionsData.reactions[baseId];
        const el = document.getElementById('metabolic-rxn-detail');
        if (!rxn) {
            el.innerHTML = `
                <div class="rxn-id">${rxnId}</div>
                <div style="color:#9D9389;">No data for this reaction in user genome</div>`;
            return;
        }

        // Parse gene string to find individual gene IDs
        const geneStr = rxn.genes || '';
        const geneLinks = geneStr ? geneStr.replace(/\b([A-Za-z][A-Za-z0-9_]+)\b/g, (match) => {
            if (match === 'or' || match === 'and') return match;
            const indices = reactionsData.gene_index && reactionsData.gene_index[match];
            if (indices && indices.length > 0) {
                return `<span class="rxn-gene-link" onclick="showGeneDetail(${indices[0]})">${match}</span>`;
            }
            return match;
        }) : '<span style="color:#9D9389">No gene assignment</span>';

        const classColor = (cls) => `<span style="display:inline-block; width:10px; height:10px; border-radius:2px; background:${FLUX_CLASS_COLORS[cls] || '#ddd'}; margin-right:4px;"></span>${FLUX_CLASS_LABELS[cls] || cls}`;

        el.innerHTML = `
            <div class="rxn-id">${rxnId}</div>
            <div class="rxn-eq">${rxn.equation || 'No equation'}</div>
            <div class="rxn-row"><span class="rxn-label">Directionality</span><span class="rxn-val">${rxn.directionality}</span></div>
            <div class="rxn-row"><span class="rxn-label">Conservation</span><span class="rxn-val">${(rxn.conservation * 100).toFixed(0)}% (${Math.round(rxn.conservation * reactionsData.n_genomes)}/${reactionsData.n_genomes})</span></div>
            <div class="rxn-row"><span class="rxn-label">Gapfilling</span><span class="rxn-val">${rxn.gapfilling === 'none' ? 'No' : rxn.gapfilling}</span></div>
            <div style="margin-top:6px; padding-top:6px; border-top:1px solid #DED5CB;">
                <div class="rxn-row"><span class="rxn-label">Flux (rich)</span><span class="rxn-val">${rxn.flux_rich.toFixed(4)}</span></div>
                <div class="rxn-row"><span class="rxn-label">Class (rich)</span><span class="rxn-val">${classColor(rxn.class_rich)}</span></div>
                <div class="rxn-row"><span class="rxn-label">Flux (minimal)</span><span class="rxn-val">${rxn.flux_min.toFixed(4)}</span></div>
                <div class="rxn-row"><span class="rxn-label">Class (minimal)</span><span class="rxn-val">${classColor(rxn.class_min)}</span></div>
            </div>
            <div style="margin-top:6px; padding-top:6px; border-top:1px solid #DED5CB;">
                <div style="font-size:10px; font-weight:600; color:#6A6158; margin-bottom:4px;">GENES</div>
                <div style="font-size:11px; line-height:1.6; word-break:break-word;">${geneLinks}</div>
            </div>
        `;
    }

    // Summary Tab Functions
    async function loadSummaryData() {
        if (summaryLoaded) return;
        try {
            const summaryFile = (CONFIG && CONFIG.data_files && CONFIG.data_files.summary) || 'summary_stats.json';
            const resp = await fetch(summaryFile);
            summaryData = await resp.json();
            summaryLoaded = true;
            // Render data in the new locations
            renderGenomeComparison();
            renderGrowthPhenotypes();
        } catch (e) {
            console.error('Failed to load summary data:', e);
        }
    }

    function renderGenomeComparison() {
        // Render genome comparison stats in Tree tab sidebar
        if (!summaryData || !genes) {
            document.getElementById('genome-comparison').innerHTML = '<span style="color:#9D9389;">Loading...</span>';
            return;
        }

        const compData = summaryData.comparison || {};
        const coreGenes = genes.filter(g => g[CONFIG.fields.PAN_CAT] === 2).length;

        const html = `
            <div style="color:var(--kb-base); line-height:1.6;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:12px;">
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:4px;">Reference Genomes</div>
                        <div style="font-size:18px; font-weight:700; color:var(--kb-primary);">${compData.n_reference_genomes || 0}</div>
                    </div>
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:4px;">Closest ANI</div>
                        <div style="font-size:18px; font-weight:700; color:#22c55e;">${(compData.closest_ani || 0).toFixed(1)}%</div>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:4px;">Total Genes</div>
                        <div style="font-size:18px; font-weight:700;">${genes.length.toLocaleString()}</div>
                    </div>
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:4px;">Core Genes</div>
                        <div style="font-size:18px; font-weight:700; color:#22c55e;">${coreGenes.toLocaleString()}</div>
                    </div>
                </div>
            </div>
        `;

        document.getElementById('genome-comparison').innerHTML = html;
    }

    function renderGrowthPhenotypes() {
        // Render growth phenotypes in Metabolic Map tab sidebar
        if (!summaryData || !summaryData.growth_phenotypes) {
            document.getElementById('growth-phenotypes').innerHTML = '<span style="color:#9D9389;">No phenotype data available</span>';
            return;
        }

        const growthData = summaryData.growth_phenotypes;

        const html = `
            <div style="color:var(--kb-base); line-height:1.6;">
                <p style="margin-bottom:10px; font-size:10px;">Metabolic modeling (FBA) tested ${growthData.total_phenotypes || 0} carbon sources</p>
                <div style="display:grid; grid-template-columns:1fr; gap:8px;">
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px; border-left:3px solid #22c55e;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:2px;">Positive Growth</div>
                        <div style="font-size:20px; font-weight:700; color:#22c55e;">${growthData.positive_growth || 0}</div>
                    </div>
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px; border-left:3px solid #ef4444;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:2px;">Negative Growth</div>
                        <div style="font-size:20px; font-weight:700; color:#ef4444;">${growthData.negative_growth || 0}</div>
                    </div>
                    <div style="padding:8px; background:var(--kb-base-lightest); border-radius:4px; border-left:3px solid #3b82f6;">
                        <div style="font-size:10px; color:var(--kb-base); margin-bottom:2px;">Avg Missing Reactions</div>
                        <div style="font-size:20px; font-weight:700; color:#3b82f6;">${(growthData.avg_negative_gaps || 0).toFixed(1)}</div>
                    </div>
                </div>
            </div>
        `;

        document.getElementById('growth-phenotypes').innerHTML = html;
    }


    // Start
    loadData();
    </script>
    <!-- Gene Detail Panel (shared across all tabs) -->
    <div class="gene-detail-panel" id="gene-detail-panel">
        <div class="gene-detail-header">
            <h3 id="detail-title">Gene Details</h3>
            <button class="gene-detail-close" onclick="closeDetail()">&times;</button>
        </div>
        <div class="gene-detail-body" id="detail-body"></div>
    </div>
</body>
</html>
